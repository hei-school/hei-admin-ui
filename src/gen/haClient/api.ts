/* tslint:disable */
/* eslint-disable */
/**
 * HEI Admin API
 * _Programmatically connect to a computer programming [school](https://hei.school)._ After [joining us](mailto:contact@hei.school), you can get an identification token from our [dev](https://dev-hei-admin.auth.eu-west-3.amazoncognito.com/oauth2/authorize?client_id=5s8cg50doahmu855rlc8fr6qmp&response_type=token&scope=email+openid&redirect_uri=https%3A%2F%2Fapi-dev.hei.school%2Fwhoami) or [prod](https://prod-hei-admin.auth.eu-west-3.amazoncognito.com/oauth2/authorize?client_id=i8bg538jpfu6mqmqb61m26trd&response_type=token&scope=email+openid&redirect_uri=https%3A%2F%2Fapi-prod.hei.school%2Fwhoami) authentication service. Then, start playing with our system!  The implementation of our API is [publicly disclosed](https://github.com/hei-school/hei-admin-api). You are welcome to try and compromise it. Happy hacking!
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @enum {string}
 */

export const AttendanceMovementType = {
  In: 'IN',
  Out: 'OUT'
} as const

export type AttendanceMovementType = (typeof AttendanceMovementType)[keyof typeof AttendanceMovementType]

/**
 *
 * @export
 * @enum {string}
 */

export const AttendanceStatus = {
  Missing: 'MISSING',
  Late: 'LATE',
  Present: 'PRESENT'
} as const

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]

/**
 *
 * @export
 * @interface AwardedCourse
 */
export interface AwardedCourse {
  /**
   *
   * @type {string}
   * @memberof AwardedCourse
   */
  id?: string
  /**
   *
   * @type {Teacher}
   * @memberof AwardedCourse
   */
  main_teacher?: Teacher
  /**
   *
   * @type {Course}
   * @memberof AwardedCourse
   */
  course?: Course
  /**
   *
   * @type {Group}
   * @memberof AwardedCourse
   */
  group?: Group
}
/**
 *
 * @export
 * @interface AwardedCourseExam
 */
export interface AwardedCourseExam {
  /**
   *
   * @type {Array<StudentExamGrade>}
   * @memberof AwardedCourseExam
   */
  exams?: Array<StudentExamGrade>
  /**
   *
   * @type {string}
   * @memberof AwardedCourseExam
   */
  id?: string
  /**
   *
   * @type {Teacher}
   * @memberof AwardedCourseExam
   */
  main_teacher?: Teacher
  /**
   *
   * @type {Course}
   * @memberof AwardedCourseExam
   */
  course?: Course
  /**
   *
   * @type {Group}
   * @memberof AwardedCourseExam
   */
  group?: Group
}
/**
 *
 * @export
 * @interface BadRequestException
 */
export interface BadRequestException {
  /**
   *
   * @type {string}
   * @memberof BadRequestException
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof BadRequestException
   */
  message?: string
}
/**
 *
 * @export
 * @interface Course
 */
export interface Course {
  /**
   *
   * @type {string}
   * @memberof Course
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Course
   */
  code?: string
  /**
   *
   * @type {string}
   * @memberof Course
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof Course
   */
  credits?: number
  /**
   *
   * @type {number}
   * @memberof Course
   */
  total_hours?: number
}
/**
 *
 * @export
 * @enum {string}
 */

export const CourseDirection = {
  Asc: 'ASC',
  Desc: 'DESC'
} as const

export type CourseDirection = (typeof CourseDirection)[keyof typeof CourseDirection]

/**
 *
 * @export
 * @interface CourseSession
 */
export interface CourseSession {
  /**
   *
   * @type {string}
   * @memberof CourseSession
   */
  id?: string
  /**
   *
   * @type {AwardedCourse}
   * @memberof CourseSession
   */
  awareded_course?: AwardedCourse
  /**
   *
   * @type {string}
   * @memberof CourseSession
   */
  begin?: string
  /**
   *
   * @type {string}
   * @memberof CourseSession
   */
  end?: string
}
/**
 *
 * @export
 * @interface CourseTemplate
 */
export interface CourseTemplate {
  /**
   *
   * @type {string}
   * @memberof CourseTemplate
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof CourseTemplate
   */
  code?: string
  /**
   *
   * @type {string}
   * @memberof CourseTemplate
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof CourseTemplate
   */
  credits?: number
  /**
   *
   * @type {number}
   * @memberof CourseTemplate
   */
  total_hours?: number
}
/**
 *
 * @export
 * @interface CreateAttendanceMovement
 */
export interface CreateAttendanceMovement {
  /**
   *
   * @type {string}
   * @memberof CreateAttendanceMovement
   */
  student_id?: string
  /**
   *
   * @type {string}
   * @memberof CreateAttendanceMovement
   */
  created_at?: string
  /**
   *
   * @type {AttendanceMovementType}
   * @memberof CreateAttendanceMovement
   */
  attendance_movement_type?: AttendanceMovementType
  /**
   *
   * @type {PlaceEnum}
   * @memberof CreateAttendanceMovement
   */
  place?: PlaceEnum
}

/**
 *
 * @export
 * @interface CreateAwardedCourse
 */
export interface CreateAwardedCourse {
  /**
   *
   * @type {string}
   * @memberof CreateAwardedCourse
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof CreateAwardedCourse
   */
  main_teacher_id?: string
  /**
   *
   * @type {string}
   * @memberof CreateAwardedCourse
   */
  course_id?: string
  /**
   *
   * @type {string}
   * @memberof CreateAwardedCourse
   */
  group_id?: string
}
/**
 *
 * @export
 * @interface CreateDelayPenaltyChange
 */
export interface CreateDelayPenaltyChange {
  /**
   *
   * @type {number}
   * @memberof CreateDelayPenaltyChange
   */
  interest_percent?: number
  /**
   *
   * @type {string}
   * @memberof CreateDelayPenaltyChange
   */
  interest_timerate?: CreateDelayPenaltyChangeInterestTimerateEnum
  /**
   *
   * @type {number}
   * @memberof CreateDelayPenaltyChange
   */
  grace_delay?: number
  /**
   *
   * @type {number}
   * @memberof CreateDelayPenaltyChange
   */
  applicability_delay_after_grace?: number
}

export const CreateDelayPenaltyChangeInterestTimerateEnum = {
  Daily: 'DAILY'
} as const

export type CreateDelayPenaltyChangeInterestTimerateEnum =
  (typeof CreateDelayPenaltyChangeInterestTimerateEnum)[keyof typeof CreateDelayPenaltyChangeInterestTimerateEnum]

/**
 *
 * @export
 * @interface CreateFee
 */
export interface CreateFee {
  /**
   *
   * @type {string}
   * @memberof CreateFee
   */
  type?: CreateFeeTypeEnum
  /**
   *
   * @type {string}
   * @memberof CreateFee
   */
  comment?: string
  /**
   *
   * @type {number}
   * @memberof CreateFee
   */
  total_amount?: number
  /**
   *
   * @type {string}
   * @memberof CreateFee
   */
  creation_datetime?: string
  /**
   *
   * @type {string}
   * @memberof CreateFee
   */
  due_datetime?: string
}

export const CreateFeeTypeEnum = {
  Tuition: 'TUITION',
  Hardware: 'HARDWARE'
} as const

export type CreateFeeTypeEnum = (typeof CreateFeeTypeEnum)[keyof typeof CreateFeeTypeEnum]

/**
 *
 * @export
 * @interface CreateGrade
 */
export interface CreateGrade {
  /**
   *
   * @type {number}
   * @memberof CreateGrade
   */
  score?: number
  /**
   *
   * @type {string}
   * @memberof CreateGrade
   */
  student_id?: string
  /**
   *
   * @type {string}
   * @memberof CreateGrade
   */
  exam_id?: string
  /**
   *
   * @type {string}
   * @memberof CreateGrade
   */
  awarded_course_id?: string
}
/**
 *
 * @export
 * @interface CreateGroup
 */
export interface CreateGroup {
  /**
   *
   * @type {Array<string>}
   * @memberof CreateGroup
   */
  students?: Array<string>
  /**
   *
   * @type {string}
   * @memberof CreateGroup
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof CreateGroup
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CreateGroup
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof CreateGroup
   */
  creation_datetime?: string
}
/**
 *
 * @export
 * @interface CreateGroupFlow
 */
export interface CreateGroupFlow {
  /**
   *
   * @type {string}
   * @memberof CreateGroupFlow
   */
  MoveType?: CreateGroupFlowMoveTypeEnum
  /**
   *
   * @type {string}
   * @memberof CreateGroupFlow
   */
  groupId?: string
  /**
   *
   * @type {string}
   * @memberof CreateGroupFlow
   */
  studentId?: string
}

export const CreateGroupFlowMoveTypeEnum = {
  Join: 'JOIN',
  Leave: 'LEAVE'
} as const

export type CreateGroupFlowMoveTypeEnum = (typeof CreateGroupFlowMoveTypeEnum)[keyof typeof CreateGroupFlowMoveTypeEnum]

/**
 *
 * @export
 * @interface CreatePayment
 */
export interface CreatePayment {
  /**
   *
   * @type {string}
   * @memberof CreatePayment
   */
  type?: CreatePaymentTypeEnum
  /**
   *
   * @type {number}
   * @memberof CreatePayment
   */
  amount?: number
  /**
   *
   * @type {string}
   * @memberof CreatePayment
   */
  comment?: string
}

export const CreatePaymentTypeEnum = {
  Cash: 'CASH',
  MobileMoney: 'MOBILE_MONEY',
  Scholarship: 'SCHOLARSHIP',
  Fix: 'FIX'
} as const

export type CreatePaymentTypeEnum = (typeof CreatePaymentTypeEnum)[keyof typeof CreatePaymentTypeEnum]

/**
 *
 * @export
 * @interface DelayPenalty
 */
export interface DelayPenalty {
  /**
   *
   * @type {string}
   * @memberof DelayPenalty
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof DelayPenalty
   */
  creation_datetime?: string
  /**
   *
   * @type {number}
   * @memberof DelayPenalty
   */
  interest_percent?: number
  /**
   *
   * @type {string}
   * @memberof DelayPenalty
   */
  interest_timerate?: DelayPenaltyInterestTimerateEnum
  /**
   *
   * @type {number}
   * @memberof DelayPenalty
   */
  grace_delay?: number
  /**
   *
   * @type {number}
   * @memberof DelayPenalty
   */
  applicability_delay_after_grace?: number
}

export const DelayPenaltyInterestTimerateEnum = {
  Daily: 'DAILY'
} as const

export type DelayPenaltyInterestTimerateEnum = (typeof DelayPenaltyInterestTimerateEnum)[keyof typeof DelayPenaltyInterestTimerateEnum]

/**
 *
 * @export
 * @enum {string}
 */

export const EnableStatus = {
  Enabled: 'ENABLED',
  Disabled: 'DISABLED'
} as const

export type EnableStatus = (typeof EnableStatus)[keyof typeof EnableStatus]

/**
 *
 * @export
 * @interface ExamDetail
 */
export interface ExamDetail {
  /**
   *
   * @type {Array<StudentGrade>}
   * @memberof ExamDetail
   */
  participants?: Array<StudentGrade>
  /**
   *
   * @type {string}
   * @memberof ExamDetail
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof ExamDetail
   */
  coefficient?: number
  /**
   *
   * @type {string}
   * @memberof ExamDetail
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof ExamDetail
   */
  examination_date?: string
  /**
   *
   * @type {string}
   * @memberof ExamDetail
   */
  awarded_course_id?: string
}
/**
 *
 * @export
 * @interface ExamInfo
 */
export interface ExamInfo {
  /**
   *
   * @type {string}
   * @memberof ExamInfo
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof ExamInfo
   */
  coefficient?: number
  /**
   *
   * @type {string}
   * @memberof ExamInfo
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof ExamInfo
   */
  examination_date?: string
  /**
   *
   * @type {string}
   * @memberof ExamInfo
   */
  awarded_course_id?: string
}
/**
 *
 * @export
 * @interface Exception
 */
export interface Exception {
  /**
   *
   * @type {string}
   * @memberof Exception
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof Exception
   */
  message?: string
}
/**
 *
 * @export
 * @interface Fee
 */
export interface Fee {
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  student_id?: string
  /**
   *
   * @type {number}
   * @memberof Fee
   */
  remaining_amount?: number
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  status?: FeeStatusEnum
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  updated_at?: string
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  type?: FeeTypeEnum
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  comment?: string
  /**
   *
   * @type {number}
   * @memberof Fee
   */
  total_amount?: number
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  creation_datetime?: string
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  due_datetime?: string
}

export const FeeStatusEnum = {
  Unpaid: 'UNPAID',
  Paid: 'PAID',
  Late: 'LATE'
} as const

export type FeeStatusEnum = (typeof FeeStatusEnum)[keyof typeof FeeStatusEnum]
export const FeeTypeEnum = {
  Tuition: 'TUITION',
  Hardware: 'HARDWARE'
} as const

export type FeeTypeEnum = (typeof FeeTypeEnum)[keyof typeof FeeTypeEnum]

/**
 *
 * @export
 * @interface Grade
 */
export interface Grade {
  /**
   *
   * @type {string}
   * @memberof Grade
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof Grade
   */
  score?: number
  /**
   *
   * @type {string}
   * @memberof Grade
   */
  created_at?: string
}
/**
 *
 * @export
 * @interface Group
 */
export interface Group {
  /**
   *
   * @type {string}
   * @memberof Group
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Group
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof Group
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof Group
   */
  creation_datetime?: string
}
/**
 *
 * @export
 * @interface GroupFlow
 */
export interface GroupFlow {
  /**
   *
   * @type {string}
   * @memberof GroupFlow
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof GroupFlow
   */
  flowdDateTime?: string
  /**
   *
   * @type {string}
   * @memberof GroupFlow
   */
  MoveType?: GroupFlowMoveTypeEnum
  /**
   *
   * @type {string}
   * @memberof GroupFlow
   */
  groupId?: string
  /**
   *
   * @type {string}
   * @memberof GroupFlow
   */
  studentId?: string
}

export const GroupFlowMoveTypeEnum = {
  Join: 'JOIN',
  Leave: 'LEAVE'
} as const

export type GroupFlowMoveTypeEnum = (typeof GroupFlowMoveTypeEnum)[keyof typeof GroupFlowMoveTypeEnum]

/**
 *
 * @export
 * @interface InternalServerException
 */
export interface InternalServerException {
  /**
   *
   * @type {string}
   * @memberof InternalServerException
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof InternalServerException
   */
  message?: string
}
/**
 *
 * @export
 * @interface Manager
 */
export interface Manager {
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  sex?: ManagerSexEnum
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  birth_date?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  address?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  entrance_datetime?: string
  /**
   *
   * @type {EnableStatus}
   * @memberof Manager
   */
  status?: EnableStatus
}

export const ManagerSexEnum = {
  M: 'M',
  F: 'F'
} as const

export type ManagerSexEnum = (typeof ManagerSexEnum)[keyof typeof ManagerSexEnum]

/**
 *
 * @export
 * @interface NotAuthorizedException
 */
export interface NotAuthorizedException {
  /**
   *
   * @type {string}
   * @memberof NotAuthorizedException
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof NotAuthorizedException
   */
  message?: string
}
/**
 *
 * @export
 * @interface Payment
 */
export interface Payment {
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  fee_id?: string
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  creation_datetime?: string
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  type?: PaymentTypeEnum
  /**
   *
   * @type {number}
   * @memberof Payment
   */
  amount?: number
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  comment?: string
}

export const PaymentTypeEnum = {
  Cash: 'CASH',
  MobileMoney: 'MOBILE_MONEY',
  Scholarship: 'SCHOLARSHIP',
  Fix: 'FIX'
} as const

export type PaymentTypeEnum = (typeof PaymentTypeEnum)[keyof typeof PaymentTypeEnum]

/**
 *
 * @export
 * @enum {string}
 */

export const PlaceEnum = {
  Ivandry: 'IVANDRY',
  Andraharo: 'ANDRAHARO'
} as const

export type PlaceEnum = (typeof PlaceEnum)[keyof typeof PlaceEnum]

/**
 *
 * @export
 * @interface ResourceNotFoundException
 */
export interface ResourceNotFoundException {
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundException
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundException
   */
  message?: string
}
/**
 *
 * @export
 * @interface Student
 */
export interface Student {
  /**
   *
   * @type {string}
   * @memberof Student
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  sex?: StudentSexEnum
  /**
   *
   * @type {string}
   * @memberof Student
   */
  birth_date?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  address?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  entrance_datetime?: string
  /**
   *
   * @type {EnableStatus}
   * @memberof Student
   */
  status?: EnableStatus
}

export const StudentSexEnum = {
  M: 'M',
  F: 'F'
} as const

export type StudentSexEnum = (typeof StudentSexEnum)[keyof typeof StudentSexEnum]

/**
 *
 * @export
 * @interface StudentAttendance
 */
export interface StudentAttendance {
  /**
   *
   * @type {string}
   * @memberof StudentAttendance
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof StudentAttendance
   */
  created_at?: string
  /**
   * if the student is late, that defines how late he or she is
   * @type {number}
   * @memberof StudentAttendance
   */
  late_of?: number
  /**
   *
   * @type {PlaceEnum}
   * @memberof StudentAttendance
   */
  place?: PlaceEnum
  /**
   *
   * @type {boolean}
   * @memberof StudentAttendance
   */
  is_late?: boolean
  /**
   *
   * @type {CourseSession}
   * @memberof StudentAttendance
   */
  course_session?: CourseSession
  /**
   *
   * @type {Student}
   * @memberof StudentAttendance
   */
  student?: Student
}

/**
 *
 * @export
 * @interface StudentAttendanceMovement
 */
export interface StudentAttendanceMovement {
  /**
   *
   * @type {string}
   * @memberof StudentAttendanceMovement
   */
  id?: string
  /**
   *
   * @type {AttendanceMovementType}
   * @memberof StudentAttendanceMovement
   */
  attendance_movement_type?: AttendanceMovementType
  /**
   *
   * @type {string}
   * @memberof StudentAttendanceMovement
   */
  created_at?: string
  /**
   *
   * @type {PlaceEnum}
   * @memberof StudentAttendanceMovement
   */
  place?: PlaceEnum
  /**
   *
   * @type {Student}
   * @memberof StudentAttendanceMovement
   */
  student?: Student
}

/**
 *
 * @export
 * @interface StudentExamGrade
 */
export interface StudentExamGrade {
  /**
   *
   * @type {Grade}
   * @memberof StudentExamGrade
   */
  grade?: Grade
  /**
   *
   * @type {string}
   * @memberof StudentExamGrade
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof StudentExamGrade
   */
  coefficient?: number
  /**
   *
   * @type {string}
   * @memberof StudentExamGrade
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof StudentExamGrade
   */
  examination_date?: string
  /**
   *
   * @type {string}
   * @memberof StudentExamGrade
   */
  awarded_course_id?: string
}
/**
 *
 * @export
 * @interface StudentGrade
 */
export interface StudentGrade {
  /**
   *
   * @type {Grade}
   * @memberof StudentGrade
   */
  grade?: Grade
  /**
   *
   * @type {string}
   * @memberof StudentGrade
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof StudentGrade
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof StudentGrade
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof StudentGrade
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof StudentGrade
   */
  email?: string
}
/**
 *
 * @export
 * @interface Teacher
 */
export interface Teacher {
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  sex?: TeacherSexEnum
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  birth_date?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  address?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  entrance_datetime?: string
  /**
   *
   * @type {EnableStatus}
   * @memberof Teacher
   */
  status?: EnableStatus
}

export const TeacherSexEnum = {
  M: 'M',
  F: 'F'
} as const

export type TeacherSexEnum = (typeof TeacherSexEnum)[keyof typeof TeacherSexEnum]

/**
 *
 * @export
 * @interface TooManyRequestsException
 */
export interface TooManyRequestsException {
  /**
   *
   * @type {string}
   * @memberof TooManyRequestsException
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof TooManyRequestsException
   */
  message?: string
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  sex?: UserSexEnum
  /**
   *
   * @type {string}
   * @memberof User
   */
  birth_date?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  address?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  entrance_datetime?: string
  /**
   *
   * @type {EnableStatus}
   * @memberof User
   */
  status?: EnableStatus
}

export const UserSexEnum = {
  M: 'M',
  F: 'F'
} as const

export type UserSexEnum = (typeof UserSexEnum)[keyof typeof UserSexEnum]

/**
 *
 * @export
 * @interface UserIdentifier
 */
export interface UserIdentifier {
  /**
   *
   * @type {string}
   * @memberof UserIdentifier
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof UserIdentifier
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof UserIdentifier
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof UserIdentifier
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof UserIdentifier
   */
  email?: string
}
/**
 *
 * @export
 * @interface Whoami
 */
export interface Whoami {
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  role?: WhoamiRoleEnum
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  bearer?: string
}

export const WhoamiRoleEnum = {
  Student: 'STUDENT',
  Teacher: 'TEACHER',
  Manager: 'MANAGER'
} as const

export type WhoamiRoleEnum = (typeof WhoamiRoleEnum)[keyof typeof WhoamiRoleEnum]

/**
 * AttendanceApi - axios parameter creator
 * @export
 */
export const AttendanceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create attendance movement of one student
     * @param {Array<CreateAttendanceMovement>} createAttendanceMovement Attendance movement to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttendanceMovement: async (createAttendanceMovement: Array<CreateAttendanceMovement>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createAttendanceMovement' is not null or undefined
      assertParamExists('createAttendanceMovement', 'createAttendanceMovement', createAttendanceMovement)
      const localVarPath = `/attendance/movement`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createAttendanceMovement, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all attendances by courses ids or student key word
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {Array<any>} [coursesIds] Filter attendance by courses ids
     * @param {Array<any>} [teachersIds] Filter attendance by teachers ids
     * @param {string} [studentKeyWord] Filter attendance by student &#x60;ref, lastname, firstname&#x60;
     * @param {string} [from] Filter attendance from a date, return attendances of the current week by default
     * @param {string} [to] Filter attendance before a date, return attendances of the current week by default
     * @param {Array<AttendanceStatus>} [attendanceStatuses] Filter attendance by attendance status value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentsAttendance: async (
      page?: number,
      pageSize?: number,
      coursesIds?: Array<any>,
      teachersIds?: Array<any>,
      studentKeyWord?: string,
      from?: string,
      to?: string,
      attendanceStatuses?: Array<AttendanceStatus>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/attendance`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      if (coursesIds) {
        localVarQueryParameter['courses_ids'] = coursesIds
      }

      if (teachersIds) {
        localVarQueryParameter['teachers_ids'] = teachersIds
      }

      if (studentKeyWord !== undefined) {
        localVarQueryParameter['student_key_word'] = studentKeyWord
      }

      if (from !== undefined) {
        localVarQueryParameter['from'] = (from as any) instanceof Date ? (from as any).toISOString() : from
      }

      if (to !== undefined) {
        localVarQueryParameter['to'] = (to as any) instanceof Date ? (to as any).toISOString() : to
      }

      if (attendanceStatuses) {
        localVarQueryParameter['attendance_statuses'] = attendanceStatuses
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * AttendanceApi - functional programming interface
 * @export
 */
export const AttendanceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AttendanceApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Create attendance movement of one student
     * @param {Array<CreateAttendanceMovement>} createAttendanceMovement Attendance movement to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAttendanceMovement(
      createAttendanceMovement: Array<CreateAttendanceMovement>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudentAttendanceMovement>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAttendanceMovement(createAttendanceMovement, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all attendances by courses ids or student key word
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {Array<any>} [coursesIds] Filter attendance by courses ids
     * @param {Array<any>} [teachersIds] Filter attendance by teachers ids
     * @param {string} [studentKeyWord] Filter attendance by student &#x60;ref, lastname, firstname&#x60;
     * @param {string} [from] Filter attendance from a date, return attendances of the current week by default
     * @param {string} [to] Filter attendance before a date, return attendances of the current week by default
     * @param {Array<AttendanceStatus>} [attendanceStatuses] Filter attendance by attendance status value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentsAttendance(
      page?: number,
      pageSize?: number,
      coursesIds?: Array<any>,
      teachersIds?: Array<any>,
      studentKeyWord?: string,
      from?: string,
      to?: string,
      attendanceStatuses?: Array<AttendanceStatus>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudentAttendance>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentsAttendance(
        page,
        pageSize,
        coursesIds,
        teachersIds,
        studentKeyWord,
        from,
        to,
        attendanceStatuses,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * AttendanceApi - factory interface
 * @export
 */
export const AttendanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AttendanceApiFp(configuration)
  return {
    /**
     *
     * @summary Create attendance movement of one student
     * @param {Array<CreateAttendanceMovement>} createAttendanceMovement Attendance movement to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttendanceMovement(createAttendanceMovement: Array<CreateAttendanceMovement>, options?: any): AxiosPromise<Array<StudentAttendanceMovement>> {
      return localVarFp.createAttendanceMovement(createAttendanceMovement, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all attendances by courses ids or student key word
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {Array<any>} [coursesIds] Filter attendance by courses ids
     * @param {Array<any>} [teachersIds] Filter attendance by teachers ids
     * @param {string} [studentKeyWord] Filter attendance by student &#x60;ref, lastname, firstname&#x60;
     * @param {string} [from] Filter attendance from a date, return attendances of the current week by default
     * @param {string} [to] Filter attendance before a date, return attendances of the current week by default
     * @param {Array<AttendanceStatus>} [attendanceStatuses] Filter attendance by attendance status value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentsAttendance(
      page?: number,
      pageSize?: number,
      coursesIds?: Array<any>,
      teachersIds?: Array<any>,
      studentKeyWord?: string,
      from?: string,
      to?: string,
      attendanceStatuses?: Array<AttendanceStatus>,
      options?: any
    ): AxiosPromise<Array<StudentAttendance>> {
      return localVarFp
        .getStudentsAttendance(page, pageSize, coursesIds, teachersIds, studentKeyWord, from, to, attendanceStatuses, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * AttendanceApi - object-oriented interface
 * @export
 * @class AttendanceApi
 * @extends {BaseAPI}
 */
export class AttendanceApi extends BaseAPI {
  /**
   *
   * @summary Create attendance movement of one student
   * @param {Array<CreateAttendanceMovement>} createAttendanceMovement Attendance movement to create
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AttendanceApi
   */
  public createAttendanceMovement(createAttendanceMovement: Array<CreateAttendanceMovement>, options?: AxiosRequestConfig) {
    return AttendanceApiFp(this.configuration)
      .createAttendanceMovement(createAttendanceMovement, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all attendances by courses ids or student key word
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {Array<any>} [coursesIds] Filter attendance by courses ids
   * @param {Array<any>} [teachersIds] Filter attendance by teachers ids
   * @param {string} [studentKeyWord] Filter attendance by student &#x60;ref, lastname, firstname&#x60;
   * @param {string} [from] Filter attendance from a date, return attendances of the current week by default
   * @param {string} [to] Filter attendance before a date, return attendances of the current week by default
   * @param {Array<AttendanceStatus>} [attendanceStatuses] Filter attendance by attendance status value
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AttendanceApi
   */
  public getStudentsAttendance(
    page?: number,
    pageSize?: number,
    coursesIds?: Array<any>,
    teachersIds?: Array<any>,
    studentKeyWord?: string,
    from?: string,
    to?: string,
    attendanceStatuses?: Array<AttendanceStatus>,
    options?: AxiosRequestConfig
  ) {
    return AttendanceApiFp(this.configuration)
      .getStudentsAttendance(page, pageSize, coursesIds, teachersIds, studentKeyWord, from, to, attendanceStatuses, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * PayingApi - axios parameter creator
 * @export
 */
export const PayingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Change current delay penalty configuration
     * @param {CreateDelayPenaltyChange} createDelayPenaltyChange Delay penalties to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDelayPenaltyChange: async (createDelayPenaltyChange: CreateDelayPenaltyChange, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createDelayPenaltyChange' is not null or undefined
      assertParamExists('createDelayPenaltyChange', 'createDelayPenaltyChange', createDelayPenaltyChange)
      const localVarPath = `/delay_penalty_change`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createDelayPenaltyChange, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create student fees
     * @param {string} studentId
     * @param {Array<CreateFee>} createFee Student fees to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStudentFees: async (studentId: string, createFee: Array<CreateFee>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('createStudentFees', 'studentId', studentId)
      // verify required parameter 'createFee' is not null or undefined
      assertParamExists('createStudentFees', 'createFee', createFee)
      const localVarPath = `/students/{student_id}/fees`.replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createFee, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create student payments
     * @param {string} studentId
     * @param {string} feeId
     * @param {Array<CreatePayment>} createPayment Student payments to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStudentPayments: async (
      studentId: string,
      feeId: string,
      createPayment: Array<CreatePayment>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('createStudentPayments', 'studentId', studentId)
      // verify required parameter 'feeId' is not null or undefined
      assertParamExists('createStudentPayments', 'feeId', feeId)
      // verify required parameter 'createPayment' is not null or undefined
      assertParamExists('createStudentPayments', 'createPayment', createPayment)
      const localVarPath = `/students/{student_id}/fees/{fee_id}/payments`
        .replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
        .replace(`{${'fee_id'}}`, encodeURIComponent(String(feeId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createPayment, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get current delay penalty
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDelayPenalty: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/delay_penalty`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all student fees filtered by status
     * @param {GetFeesStatusEnum} [status] See the PaymentStatus object for its value.
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFees: async (status?: GetFeesStatusEnum, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/fees`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get student fee by identifier
     * @param {string} studentId
     * @param {string} feeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentFeeById: async (studentId: string, feeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('getStudentFeeById', 'studentId', studentId)
      // verify required parameter 'feeId' is not null or undefined
      assertParamExists('getStudentFeeById', 'feeId', feeId)
      const localVarPath = `/students/{student_id}/fees/{fee_id}`
        .replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
        .replace(`{${'fee_id'}}`, encodeURIComponent(String(feeId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Fees can be filtered with an optional payment status parameter.
     * @summary Get all student fees ordered by due datetime desc
     * @param {string} studentId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {GetStudentFeesStatusEnum} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentFees: async (
      studentId: string,
      page?: number,
      pageSize?: number,
      status?: GetStudentFeesStatusEnum,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('getStudentFees', 'studentId', studentId)
      const localVarPath = `/students/{student_id}/fees`.replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all student payments of a specific fee. Resulting list is ordered by creation datetime desc.
     * @param {string} studentId
     * @param {string} feeId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentPayments: async (studentId: string, feeId: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('getStudentPayments', 'studentId', studentId)
      // verify required parameter 'feeId' is not null or undefined
      assertParamExists('getStudentPayments', 'feeId', feeId)
      const localVarPath = `/students/{student_id}/fees/{fee_id}/payments`
        .replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
        .replace(`{${'fee_id'}}`, encodeURIComponent(String(feeId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * PayingApi - functional programming interface
 * @export
 */
export const PayingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PayingApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Change current delay penalty configuration
     * @param {CreateDelayPenaltyChange} createDelayPenaltyChange Delay penalties to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDelayPenaltyChange(
      createDelayPenaltyChange: CreateDelayPenaltyChange,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelayPenalty>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDelayPenaltyChange(createDelayPenaltyChange, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Create student fees
     * @param {string} studentId
     * @param {Array<CreateFee>} createFee Student fees to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createStudentFees(
      studentId: string,
      createFee: Array<CreateFee>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Fee>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createStudentFees(studentId, createFee, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Create student payments
     * @param {string} studentId
     * @param {string} feeId
     * @param {Array<CreatePayment>} createPayment Student payments to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createStudentPayments(
      studentId: string,
      feeId: string,
      createPayment: Array<CreatePayment>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createStudentPayments(studentId, feeId, createPayment, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get current delay penalty
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDelayPenalty(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelayPenalty>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDelayPenalty(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all student fees filtered by status
     * @param {GetFeesStatusEnum} [status] See the PaymentStatus object for its value.
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFees(
      status?: GetFeesStatusEnum,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Fee>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFees(status, page, pageSize, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get student fee by identifier
     * @param {string} studentId
     * @param {string} feeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentFeeById(
      studentId: string,
      feeId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fee>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentFeeById(studentId, feeId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Fees can be filtered with an optional payment status parameter.
     * @summary Get all student fees ordered by due datetime desc
     * @param {string} studentId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {GetStudentFeesStatusEnum} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentFees(
      studentId: string,
      page?: number,
      pageSize?: number,
      status?: GetStudentFeesStatusEnum,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Fee>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentFees(studentId, page, pageSize, status, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all student payments of a specific fee. Resulting list is ordered by creation datetime desc.
     * @param {string} studentId
     * @param {string} feeId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentPayments(
      studentId: string,
      feeId: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentPayments(studentId, feeId, page, pageSize, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * PayingApi - factory interface
 * @export
 */
export const PayingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PayingApiFp(configuration)
  return {
    /**
     *
     * @summary Change current delay penalty configuration
     * @param {CreateDelayPenaltyChange} createDelayPenaltyChange Delay penalties to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDelayPenaltyChange(createDelayPenaltyChange: CreateDelayPenaltyChange, options?: any): AxiosPromise<DelayPenalty> {
      return localVarFp.createDelayPenaltyChange(createDelayPenaltyChange, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Create student fees
     * @param {string} studentId
     * @param {Array<CreateFee>} createFee Student fees to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStudentFees(studentId: string, createFee: Array<CreateFee>, options?: any): AxiosPromise<Array<Fee>> {
      return localVarFp.createStudentFees(studentId, createFee, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Create student payments
     * @param {string} studentId
     * @param {string} feeId
     * @param {Array<CreatePayment>} createPayment Student payments to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStudentPayments(studentId: string, feeId: string, createPayment: Array<CreatePayment>, options?: any): AxiosPromise<Array<Payment>> {
      return localVarFp.createStudentPayments(studentId, feeId, createPayment, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get current delay penalty
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDelayPenalty(options?: any): AxiosPromise<DelayPenalty> {
      return localVarFp.getDelayPenalty(options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all student fees filtered by status
     * @param {GetFeesStatusEnum} [status] See the PaymentStatus object for its value.
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFees(status?: GetFeesStatusEnum, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Fee>> {
      return localVarFp.getFees(status, page, pageSize, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get student fee by identifier
     * @param {string} studentId
     * @param {string} feeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentFeeById(studentId: string, feeId: string, options?: any): AxiosPromise<Fee> {
      return localVarFp.getStudentFeeById(studentId, feeId, options).then(request => request(axios, basePath))
    },
    /**
     * Fees can be filtered with an optional payment status parameter.
     * @summary Get all student fees ordered by due datetime desc
     * @param {string} studentId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {GetStudentFeesStatusEnum} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentFees(studentId: string, page?: number, pageSize?: number, status?: GetStudentFeesStatusEnum, options?: any): AxiosPromise<Array<Fee>> {
      return localVarFp.getStudentFees(studentId, page, pageSize, status, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all student payments of a specific fee. Resulting list is ordered by creation datetime desc.
     * @param {string} studentId
     * @param {string} feeId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentPayments(studentId: string, feeId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Payment>> {
      return localVarFp.getStudentPayments(studentId, feeId, page, pageSize, options).then(request => request(axios, basePath))
    }
  }
}

/**
 * PayingApi - object-oriented interface
 * @export
 * @class PayingApi
 * @extends {BaseAPI}
 */
export class PayingApi extends BaseAPI {
  /**
   *
   * @summary Change current delay penalty configuration
   * @param {CreateDelayPenaltyChange} createDelayPenaltyChange Delay penalties to create
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public createDelayPenaltyChange(createDelayPenaltyChange: CreateDelayPenaltyChange, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .createDelayPenaltyChange(createDelayPenaltyChange, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create student fees
   * @param {string} studentId
   * @param {Array<CreateFee>} createFee Student fees to create
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public createStudentFees(studentId: string, createFee: Array<CreateFee>, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .createStudentFees(studentId, createFee, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create student payments
   * @param {string} studentId
   * @param {string} feeId
   * @param {Array<CreatePayment>} createPayment Student payments to create
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public createStudentPayments(studentId: string, feeId: string, createPayment: Array<CreatePayment>, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .createStudentPayments(studentId, feeId, createPayment, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get current delay penalty
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getDelayPenalty(options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getDelayPenalty(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all student fees filtered by status
   * @param {GetFeesStatusEnum} [status] See the PaymentStatus object for its value.
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getFees(status?: GetFeesStatusEnum, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getFees(status, page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get student fee by identifier
   * @param {string} studentId
   * @param {string} feeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getStudentFeeById(studentId: string, feeId: string, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getStudentFeeById(studentId, feeId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Fees can be filtered with an optional payment status parameter.
   * @summary Get all student fees ordered by due datetime desc
   * @param {string} studentId
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {GetStudentFeesStatusEnum} [status]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getStudentFees(studentId: string, page?: number, pageSize?: number, status?: GetStudentFeesStatusEnum, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getStudentFees(studentId, page, pageSize, status, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all student payments of a specific fee. Resulting list is ordered by creation datetime desc.
   * @param {string} studentId
   * @param {string} feeId
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getStudentPayments(studentId: string, feeId: string, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getStudentPayments(studentId, feeId, page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const GetFeesStatusEnum = {
  Unpaid: 'UNPAID',
  Late: 'LATE',
  Paid: 'PAID'
} as const
export type GetFeesStatusEnum = (typeof GetFeesStatusEnum)[keyof typeof GetFeesStatusEnum]
/**
 * @export
 */
export const GetStudentFeesStatusEnum = {
  Unpaid: 'UNPAID',
  Paid: 'PAID',
  Late: 'LATE'
} as const
export type GetStudentFeesStatusEnum = (typeof GetStudentFeesStatusEnum)[keyof typeof GetStudentFeesStatusEnum]

/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ping`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Who am I? Tells you who you are.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/whoami`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Who am I? Tells you who you are.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async whoami(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SecurityApiFp(configuration)
  return {
    /**
     *
     * @summary pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): AxiosPromise<string> {
      return localVarFp.ping(options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Who am I? Tells you who you are.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami(options?: any): AxiosPromise<Whoami> {
      return localVarFp.whoami(options).then(request => request(axios, basePath))
    }
  }
}

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
  /**
   *
   * @summary pong
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public ping(options?: AxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .ping(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Who am I? Tells you who you are.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public whoami(options?: AxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .whoami(options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * TeachingApi - axios parameter creator
 * @export
 */
export const TeachingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Update awarded_courses when `id` are provided, create them otherwise.
     * @summary Create new awarded_courses or update existing awarded_courses
     * @param {string} id
     * @param {Array<CreateAwardedCourse>} createAwardedCourse Awarded_courses to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateAwardedCourses: async (
      id: string,
      createAwardedCourse: Array<CreateAwardedCourse>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createOrUpdateAwardedCourses', 'id', id)
      // verify required parameter 'createAwardedCourse' is not null or undefined
      assertParamExists('createOrUpdateAwardedCourses', 'createAwardedCourse', createAwardedCourse)
      const localVarPath = `/groups/{id}/awarded_courses`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createAwardedCourse, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Update courses when `id` are provided, create them otherwise.
     * @summary Create new courses or update existing courses
     * @param {Array<Course>} course Courses to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateCourses: async (course: Array<Course>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'course' is not null or undefined
      assertParamExists('createOrUpdateCourses', 'course', course)
      const localVarPath = `/courses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(course, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Update exams when `id` are provided, create them otherwise.
     * @summary Create new exams or update existing exams
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {Array<ExamInfo>} examInfo Exams to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateExams: async (
      groupId: string,
      awardedCourseId: string,
      examInfo: Array<ExamInfo>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists('createOrUpdateExams', 'groupId', groupId)
      // verify required parameter 'awardedCourseId' is not null or undefined
      assertParamExists('createOrUpdateExams', 'awardedCourseId', awardedCourseId)
      // verify required parameter 'examInfo' is not null or undefined
      assertParamExists('createOrUpdateExams', 'examInfo', examInfo)
      const localVarPath = `/groups/{group_id}/awarded_courses/{awarded_course_id}/exams`
        .replace(`{${'group_id'}}`, encodeURIComponent(String(groupId)))
        .replace(`{${'awarded_course_id'}}`, encodeURIComponent(String(awardedCourseId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(examInfo, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Update groups when `id` are provided, create them otherwise.
     * @summary Create new groups or update existing groups
     * @param {Array<CreateGroup>} createGroup Groups to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateGroups: async (createGroup: Array<CreateGroup>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createGroup' is not null or undefined
      assertParamExists('createOrUpdateGroups', 'createGroup', createGroup)
      const localVarPath = `/groups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createGroup, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create exam grades
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {string} examId
     * @param {Array<CreateGrade>} createGrade Examination with its participants with their note to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStudentExamGrade: async (
      groupId: string,
      awardedCourseId: string,
      examId: string,
      createGrade: Array<CreateGrade>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists('createStudentExamGrade', 'groupId', groupId)
      // verify required parameter 'awardedCourseId' is not null or undefined
      assertParamExists('createStudentExamGrade', 'awardedCourseId', awardedCourseId)
      // verify required parameter 'examId' is not null or undefined
      assertParamExists('createStudentExamGrade', 'examId', examId)
      // verify required parameter 'createGrade' is not null or undefined
      assertParamExists('createStudentExamGrade', 'createGrade', createGrade)
      const localVarPath = `/groups/{group_id}/awarded_courses/{awarded_course_id}/exams/{exam_id}/grades`
        .replace(`{${'group_id'}}`, encodeURIComponent(String(groupId)))
        .replace(`{${'awarded_course_id'}}`, encodeURIComponent(String(awardedCourseId)))
        .replace(`{${'exam_id'}}`, encodeURIComponent(String(examId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createGrade, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all group awarded_courses
     * @param {string} id
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllAwardedCourseByGroup: async (id: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getAllAwardedCourseByGroup', 'id', id)
      const localVarPath = `/groups/{id}/awarded_courses`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all students who follow a group
     * @param {string} id
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllStudentByGroup: async (id: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getAllStudentByGroup', 'id', id)
      const localVarPath = `/groups/{id}/students`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get a specific group awarded_course
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAwardedCoursesByIdAndGroupId: async (groupId: string, awardedCourseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists('getAwardedCoursesByIdAndGroupId', 'groupId', groupId)
      // verify required parameter 'awardedCourseId' is not null or undefined
      assertParamExists('getAwardedCoursesByIdAndGroupId', 'awardedCourseId', awardedCourseId)
      const localVarPath = `/groups/{group_id}/awarded_courses/{awarded_course_id}`
        .replace(`{${'group_id'}}`, encodeURIComponent(String(groupId)))
        .replace(`{${'awarded_course_id'}}`, encodeURIComponent(String(awardedCourseId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get course by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCourseById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCourseById', 'id', id)
      const localVarPath = `/courses/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all courses
     * @param {string} [code] Filter courses by code, case is ignored
     * @param {string} [name] Filter courses by name, case is ignored
     * @param {number} [credits] Filter courses by credits
     * @param {string} [teacherFirstName] Filter courses by teacher firstname, case is ignored
     * @param {string} [teacherLastName] Filter courses by teacher lastname, case is ignored
     * @param {CourseDirection} [creditsOrder]
     * @param {CourseDirection} [codeOrder]
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCourses: async (
      code?: string,
      name?: string,
      credits?: number,
      teacherFirstName?: string,
      teacherLastName?: string,
      creditsOrder?: CourseDirection,
      codeOrder?: CourseDirection,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/courses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (code !== undefined) {
        localVarQueryParameter['code'] = code
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (credits !== undefined) {
        localVarQueryParameter['credits'] = credits
      }

      if (teacherFirstName !== undefined) {
        localVarQueryParameter['teacher_first_name'] = teacherFirstName
      }

      if (teacherLastName !== undefined) {
        localVarQueryParameter['teacher_last_name'] = teacherLastName
      }

      if (creditsOrder !== undefined) {
        localVarQueryParameter['credits_order'] = creditsOrder
      }

      if (codeOrder !== undefined) {
        localVarQueryParameter['code_order'] = codeOrder
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get a awarded_course exam.
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {string} examId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExamById: async (groupId: string, awardedCourseId: string, examId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists('getExamById', 'groupId', groupId)
      // verify required parameter 'awardedCourseId' is not null or undefined
      assertParamExists('getExamById', 'awardedCourseId', awardedCourseId)
      // verify required parameter 'examId' is not null or undefined
      assertParamExists('getExamById', 'examId', examId)
      const localVarPath = `/groups/{group_id}/awarded_courses/{awarded_course_id}/exams/{exam_id}`
        .replace(`{${'group_id'}}`, encodeURIComponent(String(groupId)))
        .replace(`{${'awarded_course_id'}}`, encodeURIComponent(String(awardedCourseId)))
        .replace(`{${'exam_id'}}`, encodeURIComponent(String(examId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get exam details with the participants and their grades in a specified awarded_course.
     * @param {string} groupId
     * @param {string} examId
     * @param {string} awardedCourseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExamGrades: async (groupId: string, examId: string, awardedCourseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists('getExamGrades', 'groupId', groupId)
      // verify required parameter 'examId' is not null or undefined
      assertParamExists('getExamGrades', 'examId', examId)
      // verify required parameter 'awardedCourseId' is not null or undefined
      assertParamExists('getExamGrades', 'awardedCourseId', awardedCourseId)
      const localVarPath = `/groups/{group_id}/awarded_courses/{awarded_course_id}/exams/{exam_id}/grades`
        .replace(`{${'group_id'}}`, encodeURIComponent(String(groupId)))
        .replace(`{${'exam_id'}}`, encodeURIComponent(String(examId)))
        .replace(`{${'awarded_course_id'}}`, encodeURIComponent(String(awardedCourseId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all exam infos of a specified awarded_course.
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExamsByGroupIdAndAwardedCourse: async (
      groupId: string,
      awardedCourseId: string,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists('getExamsByGroupIdAndAwardedCourse', 'groupId', groupId)
      // verify required parameter 'awardedCourseId' is not null or undefined
      assertParamExists('getExamsByGroupIdAndAwardedCourse', 'awardedCourseId', awardedCourseId)
      const localVarPath = `/groups/{group_id}/awarded_courses/{awarded_course_id}/exams`
        .replace(`{${'group_id'}}`, encodeURIComponent(String(groupId)))
        .replace(`{${'awarded_course_id'}}`, encodeURIComponent(String(awardedCourseId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get group by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getGroupById', 'id', id)
      const localVarPath = `/groups/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all groups
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroups: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/groups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Return a participant with his exam grades
     * @param {string} groupId
     * @param {string} examId
     * @param {string} studentId
     * @param {string} awardedCourseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParticipantGrade: async (
      groupId: string,
      examId: string,
      studentId: string,
      awardedCourseId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists('getParticipantGrade', 'groupId', groupId)
      // verify required parameter 'examId' is not null or undefined
      assertParamExists('getParticipantGrade', 'examId', examId)
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('getParticipantGrade', 'studentId', studentId)
      // verify required parameter 'awardedCourseId' is not null or undefined
      assertParamExists('getParticipantGrade', 'awardedCourseId', awardedCourseId)
      const localVarPath = `/groups/{group_id}/awarded_courses/{awarded_course_id}/exams/{exam_id}/students/{student_id}/grade`
        .replace(`{${'group_id'}}`, encodeURIComponent(String(groupId)))
        .replace(`{${'exam_id'}}`, encodeURIComponent(String(examId)))
        .replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
        .replace(`{${'awarded_course_id'}}`, encodeURIComponent(String(awardedCourseId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get student grades.
     * @param {string} studentId
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentGrades: async (studentId: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('getStudentGrades', 'studentId', studentId)
      const localVarPath = `/students/{student_id}/grades`.replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Moving or removing a student from a group.
     * @param {string} id
     * @param {Array<CreateGroupFlow>} createGroupFlow Movement of a student towards a group to create.
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveOrDeleteStudentInGroup: async (
      id: string,
      createGroupFlow: Array<CreateGroupFlow>,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('moveOrDeleteStudentInGroup', 'id', id)
      // verify required parameter 'createGroupFlow' is not null or undefined
      assertParamExists('moveOrDeleteStudentInGroup', 'createGroupFlow', createGroupFlow)
      const localVarPath = `/students/{id}/group_flows`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createGroupFlow, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * TeachingApi - functional programming interface
 * @export
 */
export const TeachingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TeachingApiAxiosParamCreator(configuration)
  return {
    /**
     * Update awarded_courses when `id` are provided, create them otherwise.
     * @summary Create new awarded_courses or update existing awarded_courses
     * @param {string} id
     * @param {Array<CreateAwardedCourse>} createAwardedCourse Awarded_courses to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrUpdateAwardedCourses(
      id: string,
      createAwardedCourse: Array<CreateAwardedCourse>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AwardedCourse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateAwardedCourses(id, createAwardedCourse, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update courses when `id` are provided, create them otherwise.
     * @summary Create new courses or update existing courses
     * @param {Array<Course>} course Courses to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrUpdateCourses(
      course: Array<Course>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateCourses(course, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update exams when `id` are provided, create them otherwise.
     * @summary Create new exams or update existing exams
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {Array<ExamInfo>} examInfo Exams to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrUpdateExams(
      groupId: string,
      awardedCourseId: string,
      examInfo: Array<ExamInfo>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExamInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateExams(groupId, awardedCourseId, examInfo, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update groups when `id` are provided, create them otherwise.
     * @summary Create new groups or update existing groups
     * @param {Array<CreateGroup>} createGroup Groups to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrUpdateGroups(
      createGroup: Array<CreateGroup>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateGroups(createGroup, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Create exam grades
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {string} examId
     * @param {Array<CreateGrade>} createGrade Examination with its participants with their note to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createStudentExamGrade(
      groupId: string,
      awardedCourseId: string,
      examId: string,
      createGrade: Array<CreateGrade>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExamDetail>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createStudentExamGrade(groupId, awardedCourseId, examId, createGrade, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all group awarded_courses
     * @param {string} id
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllAwardedCourseByGroup(
      id: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AwardedCourse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAwardedCourseByGroup(id, page, pageSize, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all students who follow a group
     * @param {string} id
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllStudentByGroup(
      id: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Student>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllStudentByGroup(id, page, pageSize, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get a specific group awarded_course
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAwardedCoursesByIdAndGroupId(
      groupId: string,
      awardedCourseId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExamInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAwardedCoursesByIdAndGroupId(groupId, awardedCourseId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get course by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCourseById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseById(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all courses
     * @param {string} [code] Filter courses by code, case is ignored
     * @param {string} [name] Filter courses by name, case is ignored
     * @param {number} [credits] Filter courses by credits
     * @param {string} [teacherFirstName] Filter courses by teacher firstname, case is ignored
     * @param {string} [teacherLastName] Filter courses by teacher lastname, case is ignored
     * @param {CourseDirection} [creditsOrder]
     * @param {CourseDirection} [codeOrder]
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCourses(
      code?: string,
      name?: string,
      credits?: number,
      teacherFirstName?: string,
      teacherLastName?: string,
      creditsOrder?: CourseDirection,
      codeOrder?: CourseDirection,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(
        code,
        name,
        credits,
        teacherFirstName,
        teacherLastName,
        creditsOrder,
        codeOrder,
        page,
        pageSize,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get a awarded_course exam.
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {string} examId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExamById(
      groupId: string,
      awardedCourseId: string,
      examId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getExamById(groupId, awardedCourseId, examId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get exam details with the participants and their grades in a specified awarded_course.
     * @param {string} groupId
     * @param {string} examId
     * @param {string} awardedCourseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExamGrades(
      groupId: string,
      examId: string,
      awardedCourseId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getExamGrades(groupId, examId, awardedCourseId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all exam infos of a specified awarded_course.
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExamsByGroupIdAndAwardedCourse(
      groupId: string,
      awardedCourseId: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExamInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getExamsByGroupIdAndAwardedCourse(groupId, awardedCourseId, page, pageSize, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get group by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGroupById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupById(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all groups
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGroups(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGroups(page, pageSize, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Return a participant with his exam grades
     * @param {string} groupId
     * @param {string} examId
     * @param {string} studentId
     * @param {string} awardedCourseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getParticipantGrade(
      groupId: string,
      examId: string,
      studentId: string,
      awardedCourseId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGrade>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getParticipantGrade(groupId, examId, studentId, awardedCourseId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get student grades.
     * @param {string} studentId
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentGrades(
      studentId: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AwardedCourseExam>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentGrades(studentId, page, pageSize, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Moving or removing a student from a group.
     * @param {string} id
     * @param {Array<CreateGroupFlow>} createGroupFlow Movement of a student towards a group to create.
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moveOrDeleteStudentInGroup(
      id: string,
      createGroupFlow: Array<CreateGroupFlow>,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupFlow>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moveOrDeleteStudentInGroup(id, createGroupFlow, page, pageSize, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * TeachingApi - factory interface
 * @export
 */
export const TeachingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TeachingApiFp(configuration)
  return {
    /**
     * Update awarded_courses when `id` are provided, create them otherwise.
     * @summary Create new awarded_courses or update existing awarded_courses
     * @param {string} id
     * @param {Array<CreateAwardedCourse>} createAwardedCourse Awarded_courses to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateAwardedCourses(id: string, createAwardedCourse: Array<CreateAwardedCourse>, options?: any): AxiosPromise<Array<AwardedCourse>> {
      return localVarFp.createOrUpdateAwardedCourses(id, createAwardedCourse, options).then(request => request(axios, basePath))
    },
    /**
     * Update courses when `id` are provided, create them otherwise.
     * @summary Create new courses or update existing courses
     * @param {Array<Course>} course Courses to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateCourses(course: Array<Course>, options?: any): AxiosPromise<Array<Course>> {
      return localVarFp.createOrUpdateCourses(course, options).then(request => request(axios, basePath))
    },
    /**
     * Update exams when `id` are provided, create them otherwise.
     * @summary Create new exams or update existing exams
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {Array<ExamInfo>} examInfo Exams to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateExams(groupId: string, awardedCourseId: string, examInfo: Array<ExamInfo>, options?: any): AxiosPromise<Array<ExamInfo>> {
      return localVarFp.createOrUpdateExams(groupId, awardedCourseId, examInfo, options).then(request => request(axios, basePath))
    },
    /**
     * Update groups when `id` are provided, create them otherwise.
     * @summary Create new groups or update existing groups
     * @param {Array<CreateGroup>} createGroup Groups to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateGroups(createGroup: Array<CreateGroup>, options?: any): AxiosPromise<Array<Group>> {
      return localVarFp.createOrUpdateGroups(createGroup, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Create exam grades
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {string} examId
     * @param {Array<CreateGrade>} createGrade Examination with its participants with their note to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStudentExamGrade(
      groupId: string,
      awardedCourseId: string,
      examId: string,
      createGrade: Array<CreateGrade>,
      options?: any
    ): AxiosPromise<Array<ExamDetail>> {
      return localVarFp.createStudentExamGrade(groupId, awardedCourseId, examId, createGrade, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all group awarded_courses
     * @param {string} id
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllAwardedCourseByGroup(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<AwardedCourse>> {
      return localVarFp.getAllAwardedCourseByGroup(id, page, pageSize, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all students who follow a group
     * @param {string} id
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllStudentByGroup(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Student>> {
      return localVarFp.getAllStudentByGroup(id, page, pageSize, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get a specific group awarded_course
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAwardedCoursesByIdAndGroupId(groupId: string, awardedCourseId: string, options?: any): AxiosPromise<Array<ExamInfo>> {
      return localVarFp.getAwardedCoursesByIdAndGroupId(groupId, awardedCourseId, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get course by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCourseById(id: string, options?: any): AxiosPromise<Course> {
      return localVarFp.getCourseById(id, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all courses
     * @param {string} [code] Filter courses by code, case is ignored
     * @param {string} [name] Filter courses by name, case is ignored
     * @param {number} [credits] Filter courses by credits
     * @param {string} [teacherFirstName] Filter courses by teacher firstname, case is ignored
     * @param {string} [teacherLastName] Filter courses by teacher lastname, case is ignored
     * @param {CourseDirection} [creditsOrder]
     * @param {CourseDirection} [codeOrder]
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCourses(
      code?: string,
      name?: string,
      credits?: number,
      teacherFirstName?: string,
      teacherLastName?: string,
      creditsOrder?: CourseDirection,
      codeOrder?: CourseDirection,
      page?: number,
      pageSize?: number,
      options?: any
    ): AxiosPromise<Array<Course>> {
      return localVarFp
        .getCourses(code, name, credits, teacherFirstName, teacherLastName, creditsOrder, codeOrder, page, pageSize, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get a awarded_course exam.
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {string} examId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExamById(groupId: string, awardedCourseId: string, examId: string, options?: any): AxiosPromise<ExamInfo> {
      return localVarFp.getExamById(groupId, awardedCourseId, examId, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get exam details with the participants and their grades in a specified awarded_course.
     * @param {string} groupId
     * @param {string} examId
     * @param {string} awardedCourseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExamGrades(groupId: string, examId: string, awardedCourseId: string, options?: any): AxiosPromise<ExamDetail> {
      return localVarFp.getExamGrades(groupId, examId, awardedCourseId, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all exam infos of a specified awarded_course.
     * @param {string} groupId
     * @param {string} awardedCourseId
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExamsByGroupIdAndAwardedCourse(
      groupId: string,
      awardedCourseId: string,
      page?: number,
      pageSize?: number,
      options?: any
    ): AxiosPromise<Array<ExamInfo>> {
      return localVarFp.getExamsByGroupIdAndAwardedCourse(groupId, awardedCourseId, page, pageSize, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get group by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupById(id: string, options?: any): AxiosPromise<Group> {
      return localVarFp.getGroupById(id, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all groups
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroups(page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Group>> {
      return localVarFp.getGroups(page, pageSize, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Return a participant with his exam grades
     * @param {string} groupId
     * @param {string} examId
     * @param {string} studentId
     * @param {string} awardedCourseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParticipantGrade(groupId: string, examId: string, studentId: string, awardedCourseId: string, options?: any): AxiosPromise<StudentGrade> {
      return localVarFp.getParticipantGrade(groupId, examId, studentId, awardedCourseId, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get student grades.
     * @param {string} studentId
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentGrades(studentId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<AwardedCourseExam>> {
      return localVarFp.getStudentGrades(studentId, page, pageSize, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Moving or removing a student from a group.
     * @param {string} id
     * @param {Array<CreateGroupFlow>} createGroupFlow Movement of a student towards a group to create.
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveOrDeleteStudentInGroup(id: string, createGroupFlow: Array<CreateGroupFlow>, page?: number, pageSize?: number, options?: any): AxiosPromise<GroupFlow> {
      return localVarFp.moveOrDeleteStudentInGroup(id, createGroupFlow, page, pageSize, options).then(request => request(axios, basePath))
    }
  }
}

/**
 * TeachingApi - object-oriented interface
 * @export
 * @class TeachingApi
 * @extends {BaseAPI}
 */
export class TeachingApi extends BaseAPI {
  /**
   * Update awarded_courses when `id` are provided, create them otherwise.
   * @summary Create new awarded_courses or update existing awarded_courses
   * @param {string} id
   * @param {Array<CreateAwardedCourse>} createAwardedCourse Awarded_courses to update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public createOrUpdateAwardedCourses(id: string, createAwardedCourse: Array<CreateAwardedCourse>, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .createOrUpdateAwardedCourses(id, createAwardedCourse, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Update courses when `id` are provided, create them otherwise.
   * @summary Create new courses or update existing courses
   * @param {Array<Course>} course Courses to update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public createOrUpdateCourses(course: Array<Course>, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .createOrUpdateCourses(course, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Update exams when `id` are provided, create them otherwise.
   * @summary Create new exams or update existing exams
   * @param {string} groupId
   * @param {string} awardedCourseId
   * @param {Array<ExamInfo>} examInfo Exams to update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public createOrUpdateExams(groupId: string, awardedCourseId: string, examInfo: Array<ExamInfo>, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .createOrUpdateExams(groupId, awardedCourseId, examInfo, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Update groups when `id` are provided, create them otherwise.
   * @summary Create new groups or update existing groups
   * @param {Array<CreateGroup>} createGroup Groups to update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public createOrUpdateGroups(createGroup: Array<CreateGroup>, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .createOrUpdateGroups(createGroup, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create exam grades
   * @param {string} groupId
   * @param {string} awardedCourseId
   * @param {string} examId
   * @param {Array<CreateGrade>} createGrade Examination with its participants with their note to create.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public createStudentExamGrade(groupId: string, awardedCourseId: string, examId: string, createGrade: Array<CreateGrade>, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .createStudentExamGrade(groupId, awardedCourseId, examId, createGrade, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all group awarded_courses
   * @param {string} id
   * @param {number} [page] Set value to 1 by default if null is provided
   * @param {number} [pageSize] Set value to 15 by default if null is provided
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getAllAwardedCourseByGroup(id: string, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getAllAwardedCourseByGroup(id, page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all students who follow a group
   * @param {string} id
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getAllStudentByGroup(id: string, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getAllStudentByGroup(id, page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get a specific group awarded_course
   * @param {string} groupId
   * @param {string} awardedCourseId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getAwardedCoursesByIdAndGroupId(groupId: string, awardedCourseId: string, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getAwardedCoursesByIdAndGroupId(groupId, awardedCourseId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get course by identifier
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getCourseById(id: string, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getCourseById(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all courses
   * @param {string} [code] Filter courses by code, case is ignored
   * @param {string} [name] Filter courses by name, case is ignored
   * @param {number} [credits] Filter courses by credits
   * @param {string} [teacherFirstName] Filter courses by teacher firstname, case is ignored
   * @param {string} [teacherLastName] Filter courses by teacher lastname, case is ignored
   * @param {CourseDirection} [creditsOrder]
   * @param {CourseDirection} [codeOrder]
   * @param {number} [page] Set value to 1 by default if null is provided
   * @param {number} [pageSize] Set value to 15 by default if null is provided
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getCourses(
    code?: string,
    name?: string,
    credits?: number,
    teacherFirstName?: string,
    teacherLastName?: string,
    creditsOrder?: CourseDirection,
    codeOrder?: CourseDirection,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig
  ) {
    return TeachingApiFp(this.configuration)
      .getCourses(code, name, credits, teacherFirstName, teacherLastName, creditsOrder, codeOrder, page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get a awarded_course exam.
   * @param {string} groupId
   * @param {string} awardedCourseId
   * @param {string} examId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getExamById(groupId: string, awardedCourseId: string, examId: string, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getExamById(groupId, awardedCourseId, examId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get exam details with the participants and their grades in a specified awarded_course.
   * @param {string} groupId
   * @param {string} examId
   * @param {string} awardedCourseId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getExamGrades(groupId: string, examId: string, awardedCourseId: string, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getExamGrades(groupId, examId, awardedCourseId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all exam infos of a specified awarded_course.
   * @param {string} groupId
   * @param {string} awardedCourseId
   * @param {number} [page] Set value to 1 by default if null is provided
   * @param {number} [pageSize] Set value to 15 by default if null is provided
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getExamsByGroupIdAndAwardedCourse(groupId: string, awardedCourseId: string, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getExamsByGroupIdAndAwardedCourse(groupId, awardedCourseId, page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get group by identifier
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getGroupById(id: string, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getGroupById(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all groups
   * @param {number} [page] Set value to 1 by default if null is provided
   * @param {number} [pageSize] Set value to 15 by default if null is provided
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getGroups(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getGroups(page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Return a participant with his exam grades
   * @param {string} groupId
   * @param {string} examId
   * @param {string} studentId
   * @param {string} awardedCourseId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getParticipantGrade(groupId: string, examId: string, studentId: string, awardedCourseId: string, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getParticipantGrade(groupId, examId, studentId, awardedCourseId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get student grades.
   * @param {string} studentId
   * @param {number} [page] Set value to 1 by default if null is provided
   * @param {number} [pageSize] Set value to 15 by default if null is provided
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getStudentGrades(studentId: string, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getStudentGrades(studentId, page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Moving or removing a student from a group.
   * @param {string} id
   * @param {Array<CreateGroupFlow>} createGroupFlow Movement of a student towards a group to create.
   * @param {number} [page] Set value to 1 by default if null is provided
   * @param {number} [pageSize] Set value to 15 by default if null is provided
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public moveOrDeleteStudentInGroup(id: string, createGroupFlow: Array<CreateGroupFlow>, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .moveOrDeleteStudentInGroup(id, createGroupFlow, page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Update students when `id` are provided, create them otherwise.
     * @summary Create new students or update existing students
     * @param {Array<Student>} student
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateStudents: async (student: Array<Student>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'student' is not null or undefined
      assertParamExists('createOrUpdateStudents', 'student', student)
      const localVarPath = `/students`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(student, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Update teachers when `id` are provided, create them otherwise.
     * @summary Create new teachers or update existing teachers
     * @param {Array<Teacher>} teacher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateTeachers: async (teacher: Array<Teacher>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'teacher' is not null or undefined
      assertParamExists('createOrUpdateTeachers', 'teacher', teacher)
      const localVarPath = `/teachers`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(teacher, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get manager by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagerById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getManagerById', 'id', id)
      const localVarPath = `/managers/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all managers
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagers: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/managers`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get student by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getStudentById', 'id', id)
      const localVarPath = `/students/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all students
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [ref] Filter students by ref, case is ignored
     * @param {string} [firstName] Filter students by first name, case is ignored
     * @param {string} [lastName] Filter students by last name, case is ignored
     * @param {string} [courseId] Filter students by course they are linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudents: async (
      page?: number,
      pageSize?: number,
      ref?: string,
      firstName?: string,
      lastName?: string,
      courseId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/students`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      if (ref !== undefined) {
        localVarQueryParameter['ref'] = ref
      }

      if (firstName !== undefined) {
        localVarQueryParameter['first_name'] = firstName
      }

      if (lastName !== undefined) {
        localVarQueryParameter['last_name'] = lastName
      }

      if (courseId !== undefined) {
        localVarQueryParameter['course_id'] = courseId
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get teacher by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeacherById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getTeacherById', 'id', id)
      const localVarPath = `/teachers/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all teachers
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [ref] Filter teachers by ref, case is ignored
     * @param {string} [firstName] Filter teachers by first name, case is ignored
     * @param {string} [lastName] Filter teachers by last name, case is ignored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeachers: async (
      page?: number,
      pageSize?: number,
      ref?: string,
      firstName?: string,
      lastName?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/teachers`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      if (ref !== undefined) {
        localVarQueryParameter['ref'] = ref
      }

      if (firstName !== undefined) {
        localVarQueryParameter['first_name'] = firstName
      }

      if (lastName !== undefined) {
        localVarQueryParameter['last_name'] = lastName
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
  return {
    /**
     * Update students when `id` are provided, create them otherwise.
     * @summary Create new students or update existing students
     * @param {Array<Student>} student
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrUpdateStudents(
      student: Array<Student>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Student>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateStudents(student, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update teachers when `id` are provided, create them otherwise.
     * @summary Create new teachers or update existing teachers
     * @param {Array<Teacher>} teacher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrUpdateTeachers(
      teacher: Array<Teacher>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Teacher>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateTeachers(teacher, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get manager by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getManagerById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manager>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getManagerById(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all managers
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getManagers(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Manager>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getManagers(page, pageSize, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get student by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Student>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentById(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all students
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [ref] Filter students by ref, case is ignored
     * @param {string} [firstName] Filter students by first name, case is ignored
     * @param {string} [lastName] Filter students by last name, case is ignored
     * @param {string} [courseId] Filter students by course they are linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudents(
      page?: number,
      pageSize?: number,
      ref?: string,
      firstName?: string,
      lastName?: string,
      courseId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Student>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudents(page, pageSize, ref, firstName, lastName, courseId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get teacher by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTeacherById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTeacherById(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all teachers
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [ref] Filter teachers by ref, case is ignored
     * @param {string} [firstName] Filter teachers by first name, case is ignored
     * @param {string} [lastName] Filter teachers by last name, case is ignored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTeachers(
      page?: number,
      pageSize?: number,
      ref?: string,
      firstName?: string,
      lastName?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Teacher>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachers(page, pageSize, ref, firstName, lastName, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UsersApiFp(configuration)
  return {
    /**
     * Update students when `id` are provided, create them otherwise.
     * @summary Create new students or update existing students
     * @param {Array<Student>} student
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateStudents(student: Array<Student>, options?: any): AxiosPromise<Array<Student>> {
      return localVarFp.createOrUpdateStudents(student, options).then(request => request(axios, basePath))
    },
    /**
     * Update teachers when `id` are provided, create them otherwise.
     * @summary Create new teachers or update existing teachers
     * @param {Array<Teacher>} teacher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateTeachers(teacher: Array<Teacher>, options?: any): AxiosPromise<Array<Teacher>> {
      return localVarFp.createOrUpdateTeachers(teacher, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get manager by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagerById(id: string, options?: any): AxiosPromise<Manager> {
      return localVarFp.getManagerById(id, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all managers
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagers(page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Manager>> {
      return localVarFp.getManagers(page, pageSize, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get student by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentById(id: string, options?: any): AxiosPromise<Student> {
      return localVarFp.getStudentById(id, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all students
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [ref] Filter students by ref, case is ignored
     * @param {string} [firstName] Filter students by first name, case is ignored
     * @param {string} [lastName] Filter students by last name, case is ignored
     * @param {string} [courseId] Filter students by course they are linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudents(
      page?: number,
      pageSize?: number,
      ref?: string,
      firstName?: string,
      lastName?: string,
      courseId?: string,
      options?: any
    ): AxiosPromise<Array<Student>> {
      return localVarFp.getStudents(page, pageSize, ref, firstName, lastName, courseId, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get teacher by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeacherById(id: string, options?: any): AxiosPromise<Teacher> {
      return localVarFp.getTeacherById(id, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all teachers
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [ref] Filter teachers by ref, case is ignored
     * @param {string} [firstName] Filter teachers by first name, case is ignored
     * @param {string} [lastName] Filter teachers by last name, case is ignored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeachers(page?: number, pageSize?: number, ref?: string, firstName?: string, lastName?: string, options?: any): AxiosPromise<Array<Teacher>> {
      return localVarFp.getTeachers(page, pageSize, ref, firstName, lastName, options).then(request => request(axios, basePath))
    }
  }
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * Update students when `id` are provided, create them otherwise.
   * @summary Create new students or update existing students
   * @param {Array<Student>} student
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createOrUpdateStudents(student: Array<Student>, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .createOrUpdateStudents(student, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Update teachers when `id` are provided, create them otherwise.
   * @summary Create new teachers or update existing teachers
   * @param {Array<Teacher>} teacher
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createOrUpdateTeachers(teacher: Array<Teacher>, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .createOrUpdateTeachers(teacher, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get manager by identifier
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getManagerById(id: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getManagerById(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all managers
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getManagers(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getManagers(page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get student by identifier
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getStudentById(id: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getStudentById(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all students
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {string} [ref] Filter students by ref, case is ignored
   * @param {string} [firstName] Filter students by first name, case is ignored
   * @param {string} [lastName] Filter students by last name, case is ignored
   * @param {string} [courseId] Filter students by course they are linked to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getStudents(page?: number, pageSize?: number, ref?: string, firstName?: string, lastName?: string, courseId?: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getStudents(page, pageSize, ref, firstName, lastName, courseId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get teacher by identifier
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getTeacherById(id: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getTeacherById(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all teachers
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {string} [ref] Filter teachers by ref, case is ignored
   * @param {string} [firstName] Filter teachers by first name, case is ignored
   * @param {string} [lastName] Filter teachers by last name, case is ignored
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getTeachers(page?: number, pageSize?: number, ref?: string, firstName?: string, lastName?: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getTeachers(page, pageSize, ref, firstName, lastName, options)
      .then(request => request(this.axios, this.basePath))
  }
}
