/* tslint:disable */
/* eslint-disable */
/**
 * HEI Admin API
 * _Programmatically connect to a computer programming [school](https://hei.school)._ After [joining us](mailto:contact@hei.school), you can get an identification token from our [dev](https://dev-hei-admin.auth.eu-west-3.amazoncognito.com/oauth2/authorize?client_id=5s8cg50doahmu855rlc8fr6qmp&response_type=token&scope=email+openid&redirect_uri=https%3A%2F%2Fapi-dev.hei.school%2Fwhoami) or [prod](https://prod-hei-admin.auth.eu-west-3.amazoncognito.com/oauth2/authorize?client_id=i8bg538jpfu6mqmqb61m26trd&response_type=token&scope=email+openid&redirect_uri=https%3A%2F%2Fapi-prod.hei.school%2Fwhoami) authentication service. Then, start playing with our system!  The implementation of our API is [publicly disclosed](https://github.com/hei-school/hei-admin-api). You are welcome to try and compromise it. Happy hacking!
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, { AxiosInstance, AxiosPromise, AxiosRequestConfig } from 'axios'
import { Configuration } from './configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, createRequestFunction, serializeDataIfNeeded, setBearerAuthToObject, setSearchParams, toPathString } from './common'
// @ts-ignore
import { BASE_PATH, BaseAPI, RequestArgs, RequiredError } from './base'

/**
 *
 * @export
 * @interface BadRequestException
 */
export interface BadRequestException {
  /**
   *
   * @type {string}
   * @memberof BadRequestException
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof BadRequestException
   */
  message?: string
}
/**
 *
 * @export
 * @interface Course
 */
export interface Course {
  /**
   *
   * @type {string}
   * @memberof Course
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Course
   */
  code?: string
  /**
   *
   * @type {string}
   * @memberof Course
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof Course
   */
  credits?: number
  /**
   *
   * @type {number}
   * @memberof Course
   */
  total_hours?: number
  /**
   *
   * @type {Teacher}
   * @memberof Course
   */
  main_teacher?: Teacher
}
/**
 *
 * @export
 * @interface CourseAllOf
 */
export interface CourseAllOf {
  /**
   *
   * @type {Teacher}
   * @memberof CourseAllOf
   */
  main_teacher?: Teacher
}
/**
 *
 * @export
 * @enum {string}
 */

export const CourseDirection = {
  Asc: 'ASC',
  Desc: 'DESC'
} as const

export type CourseDirection = (typeof CourseDirection)[keyof typeof CourseDirection]

/**
 *
 * @export
 * @enum {string}
 */

export const CourseStatus = {
  Linked: 'LINKED',
  Unlinked: 'UNLINKED'
} as const

export type CourseStatus = (typeof CourseStatus)[keyof typeof CourseStatus]

/**
 *
 * @export
 * @interface CourseTemplate
 */
export interface CourseTemplate {
  /**
   *
   * @type {string}
   * @memberof CourseTemplate
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof CourseTemplate
   */
  code?: string
  /**
   *
   * @type {string}
   * @memberof CourseTemplate
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof CourseTemplate
   */
  credits?: number
  /**
   *
   * @type {number}
   * @memberof CourseTemplate
   */
  total_hours?: number
}
/**
 *
 * @export
 * @interface CreateDelayPenaltyChange
 */
export interface CreateDelayPenaltyChange {
  /**
   *
   * @type {number}
   * @memberof CreateDelayPenaltyChange
   */
  interest_percent?: number
  /**
   *
   * @type {string}
   * @memberof CreateDelayPenaltyChange
   */
  interest_timerate?: CreateDelayPenaltyChangeInterestTimerateEnum
  /**
   *
   * @type {number}
   * @memberof CreateDelayPenaltyChange
   */
  grace_delay?: number
  /**
   *
   * @type {number}
   * @memberof CreateDelayPenaltyChange
   */
  applicability_delay_after_grace?: number
}

export const CreateDelayPenaltyChangeInterestTimerateEnum = {
  Daily: 'DAILY'
} as const

export type CreateDelayPenaltyChangeInterestTimerateEnum =
  (typeof CreateDelayPenaltyChangeInterestTimerateEnum)[keyof typeof CreateDelayPenaltyChangeInterestTimerateEnum]

/**
 *
 * @export
 * @interface CreateFee
 */
export interface CreateFee {
  /**
   *
   * @type {string}
   * @memberof CreateFee
   */
  type?: CreateFeeTypeEnum
  /**
   *
   * @type {string}
   * @memberof CreateFee
   */
  comment?: string
  /**
   *
   * @type {number}
   * @memberof CreateFee
   */
  total_amount?: number
  /**
   *
   * @type {string}
   * @memberof CreateFee
   */
  creation_datetime?: string
  /**
   *
   * @type {string}
   * @memberof CreateFee
   */
  due_datetime?: string
}

export const CreateFeeTypeEnum = {
  Tuition: 'TUITION',
  Hardware: 'HARDWARE'
} as const

export type CreateFeeTypeEnum = (typeof CreateFeeTypeEnum)[keyof typeof CreateFeeTypeEnum]

/**
 *
 * @export
 * @interface CreateOrUpdateStudents200ResponseInner
 */
export interface CreateOrUpdateStudents200ResponseInner {
  /**
   *
   * @type {string}
   * @memberof CreateOrUpdateStudents200ResponseInner
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof CreateOrUpdateStudents200ResponseInner
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof CreateOrUpdateStudents200ResponseInner
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof CreateOrUpdateStudents200ResponseInner
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof CreateOrUpdateStudents200ResponseInner
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof CreateOrUpdateStudents200ResponseInner
   */
  sex?: CreateOrUpdateStudents200ResponseInnerSexEnum
  /**
   *
   * @type {string}
   * @memberof CreateOrUpdateStudents200ResponseInner
   */
  birth_date?: string
  /**
   *
   * @type {string}
   * @memberof CreateOrUpdateStudents200ResponseInner
   */
  address?: string
  /**
   *
   * @type {string}
   * @memberof CreateOrUpdateStudents200ResponseInner
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof CreateOrUpdateStudents200ResponseInner
   */
  entrance_datetime?: string
  /**
   *
   * @type {EnableStatus}
   * @memberof CreateOrUpdateStudents200ResponseInner
   */
  status?: EnableStatus
}

export const CreateOrUpdateStudents200ResponseInnerSexEnum = {
  M: 'M',
  F: 'F'
} as const

export type CreateOrUpdateStudents200ResponseInnerSexEnum =
  (typeof CreateOrUpdateStudents200ResponseInnerSexEnum)[keyof typeof CreateOrUpdateStudents200ResponseInnerSexEnum]

/**
 *
 * @export
 * @interface CreatePayment
 */
export interface CreatePayment {
  /**
   *
   * @type {string}
   * @memberof CreatePayment
   */
  type?: CreatePaymentTypeEnum
  /**
   *
   * @type {number}
   * @memberof CreatePayment
   */
  amount?: number
  /**
   *
   * @type {string}
   * @memberof CreatePayment
   */
  comment?: string
}

export const CreatePaymentTypeEnum = {
  Cash: 'CASH',
  MobileMoney: 'MOBILE_MONEY',
  Scholarship: 'SCHOLARSHIP',
  Fix: 'FIX'
} as const

export type CreatePaymentTypeEnum = (typeof CreatePaymentTypeEnum)[keyof typeof CreatePaymentTypeEnum]

/**
 *
 * @export
 * @interface CrupdateCourse
 */
export interface CrupdateCourse {
  /**
   *
   * @type {string}
   * @memberof CrupdateCourse
   */
  main_teacher_id?: string
  /**
   *
   * @type {string}
   * @memberof CrupdateCourse
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof CrupdateCourse
   */
  code?: string
  /**
   *
   * @type {string}
   * @memberof CrupdateCourse
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof CrupdateCourse
   */
  credits?: number
  /**
   *
   * @type {number}
   * @memberof CrupdateCourse
   */
  total_hours?: number
}
/**
 *
 * @export
 * @interface DelayPenalty
 */
export interface DelayPenalty {
  /**
   *
   * @type {string}
   * @memberof DelayPenalty
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof DelayPenalty
   */
  creation_datetime?: string
  /**
   *
   * @type {number}
   * @memberof DelayPenalty
   */
  interest_percent?: number
  /**
   *
   * @type {string}
   * @memberof DelayPenalty
   */
  interest_timerate?: DelayPenaltyInterestTimerateEnum
  /**
   *
   * @type {number}
   * @memberof DelayPenalty
   */
  grace_delay?: number
  /**
   *
   * @type {number}
   * @memberof DelayPenalty
   */
  applicability_delay_after_grace?: number
}

export const DelayPenaltyInterestTimerateEnum = {
  Daily: 'DAILY'
} as const

export type DelayPenaltyInterestTimerateEnum = (typeof DelayPenaltyInterestTimerateEnum)[keyof typeof DelayPenaltyInterestTimerateEnum]

/**
 *
 * @export
 * @enum {string}
 */

export const EnableStatus = {
  Enabled: 'ENABLED',
  Disabled: 'DISABLED'
} as const

export type EnableStatus = (typeof EnableStatus)[keyof typeof EnableStatus]

/**
 *
 * @export
 * @interface ExamDetail
 */
export interface ExamDetail {
  /**
   *
   * @type {Array<StudentGrade>}
   * @memberof ExamDetail
   */
  participants?: Array<StudentGrade>
  /**
   *
   * @type {string}
   * @memberof ExamDetail
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof ExamDetail
   */
  coefficient?: number
  /**
   *
   * @type {string}
   * @memberof ExamDetail
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof ExamDetail
   */
  examination_date?: string
}
/**
 *
 * @export
 * @interface ExamInfo
 */
export interface ExamInfo {
  /**
   *
   * @type {string}
   * @memberof ExamInfo
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof ExamInfo
   */
  coefficient?: number
  /**
   *
   * @type {string}
   * @memberof ExamInfo
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof ExamInfo
   */
  examination_date?: string
}
/**
 *
 * @export
 * @interface Exception
 */
export interface Exception {
  /**
   *
   * @type {string}
   * @memberof Exception
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof Exception
   */
  message?: string
}
/**
 *
 * @export
 * @interface Fee
 */
export interface Fee {
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  student_id?: string
  /**
   *
   * @type {number}
   * @memberof Fee
   */
  remaining_amount?: number
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  status?: FeeStatusEnum
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  updated_at?: string
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  type?: FeeTypeEnum
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  comment?: string
  /**
   *
   * @type {number}
   * @memberof Fee
   */
  total_amount?: number
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  creation_datetime?: string
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  due_datetime?: string
}

export const FeeStatusEnum = {
  Unpaid: 'UNPAID',
  Paid: 'PAID',
  Late: 'LATE'
} as const

export type FeeStatusEnum = (typeof FeeStatusEnum)[keyof typeof FeeStatusEnum]
export const FeeTypeEnum = {
  Tuition: 'TUITION',
  Hardware: 'HARDWARE'
} as const

export type FeeTypeEnum = (typeof FeeTypeEnum)[keyof typeof FeeTypeEnum]

/**
 *
 * @export
 * @interface Grade
 */
export interface Grade {
  /**
   *
   * @type {number}
   * @memberof Grade
   */
  score?: number
  /**
   *
   * @type {string}
   * @memberof Grade
   */
  created_at?: string
}
/**
 *
 * @export
 * @interface Group
 */
export interface Group {
  /**
   *
   * @type {string}
   * @memberof Group
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Group
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof Group
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof Group
   */
  creation_datetime?: string
}
/**
 *
 * @export
 * @interface InternalServerException
 */
export interface InternalServerException {
  /**
   *
   * @type {string}
   * @memberof InternalServerException
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof InternalServerException
   */
  message?: string
}
/**
 *
 * @export
 * @interface Manager
 */
export interface Manager {
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  sex?: ManagerSexEnum
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  birth_date?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  address?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  entrance_datetime?: string
  /**
   *
   * @type {EnableStatus}
   * @memberof Manager
   */
  status?: EnableStatus
}

export const ManagerSexEnum = {
  M: 'M',
  F: 'F'
} as const

export type ManagerSexEnum = (typeof ManagerSexEnum)[keyof typeof ManagerSexEnum]

/**
 *
 * @export
 * @interface NotAuthorizedException
 */
export interface NotAuthorizedException {
  /**
   *
   * @type {string}
   * @memberof NotAuthorizedException
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof NotAuthorizedException
   */
  message?: string
}
/**
 *
 * @export
 * @enum {string}
 */

export const Order = {
  Asc: 'ASC',
  Desc: 'DESC'
} as const

export type Order = (typeof Order)[keyof typeof Order]

/**
 *
 * @export
 * @interface Payment
 */
export interface Payment {
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  fee_id?: string
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  creation_datetime?: string
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  type?: PaymentTypeEnum
  /**
   *
   * @type {number}
   * @memberof Payment
   */
  amount?: number
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  comment?: string
}

export const PaymentTypeEnum = {
  Cash: 'CASH',
  MobileMoney: 'MOBILE_MONEY',
  Scholarship: 'SCHOLARSHIP',
  Fix: 'FIX'
} as const

export type PaymentTypeEnum = (typeof PaymentTypeEnum)[keyof typeof PaymentTypeEnum]

/**
 *
 * @export
 * @interface ResourceNotFoundException
 */
export interface ResourceNotFoundException {
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundException
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundException
   */
  message?: string
}
/**
 *
 * @export
 * @interface Student
 */
export interface Student {
  /**
   *
   * @type {string}
   * @memberof Student
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  sex?: StudentSexEnum
  /**
   *
   * @type {string}
   * @memberof Student
   */
  birth_date?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  address?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  entrance_datetime?: string
  /**
   *
   * @type {EnableStatus}
   * @memberof Student
   */
  status?: EnableStatus
}

export const StudentSexEnum = {
  M: 'M',
  F: 'F'
} as const

export type StudentSexEnum = (typeof StudentSexEnum)[keyof typeof StudentSexEnum]

/**
 *
 * @export
 * @interface StudentCourseExam
 */
export interface StudentCourseExam {
  /**
   *
   * @type {Array<StudentExamGrade>}
   * @memberof StudentCourseExam
   */
  exams?: Array<StudentExamGrade>
  /**
   *
   * @type {string}
   * @memberof StudentCourseExam
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof StudentCourseExam
   */
  code?: string
  /**
   *
   * @type {string}
   * @memberof StudentCourseExam
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof StudentCourseExam
   */
  credits?: number
  /**
   *
   * @type {number}
   * @memberof StudentCourseExam
   */
  total_hours?: number
  /**
   *
   * @type {Teacher}
   * @memberof StudentCourseExam
   */
  main_teacher?: Teacher
}
/**
 *
 * @export
 * @interface StudentExamGrade
 */
export interface StudentExamGrade {
  /**
   *
   * @type {Grade}
   * @memberof StudentExamGrade
   */
  grade?: Grade
  /**
   *
   * @type {string}
   * @memberof StudentExamGrade
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof StudentExamGrade
   */
  coefficient?: number
  /**
   *
   * @type {string}
   * @memberof StudentExamGrade
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof StudentExamGrade
   */
  examination_date?: string
}
/**
 *
 * @export
 * @interface StudentGrade
 */
export interface StudentGrade {
  /**
   *
   * @type {Grade}
   * @memberof StudentGrade
   */
  grade?: Grade
  /**
   *
   * @type {string}
   * @memberof StudentGrade
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof StudentGrade
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof StudentGrade
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof StudentGrade
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof StudentGrade
   */
  email?: string
}
/**
 *
 * @export
 * @interface Teacher
 */
export interface Teacher {
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  sex?: TeacherSexEnum
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  birth_date?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  address?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  entrance_datetime?: string
  /**
   *
   * @type {EnableStatus}
   * @memberof Teacher
   */
  status?: EnableStatus
}

export const TeacherSexEnum = {
  M: 'M',
  F: 'F'
} as const

export type TeacherSexEnum = (typeof TeacherSexEnum)[keyof typeof TeacherSexEnum]

/**
 *
 * @export
 * @interface TooManyRequestsException
 */
export interface TooManyRequestsException {
  /**
   *
   * @type {string}
   * @memberof TooManyRequestsException
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof TooManyRequestsException
   */
  message?: string
}
/**
 *
 * @export
 * @interface UpdateStudentCourse
 */
export interface UpdateStudentCourse {
  /**
   *
   * @type {string}
   * @memberof UpdateStudentCourse
   */
  course_id?: string
  /**
   *
   * @type {CourseStatus}
   * @memberof UpdateStudentCourse
   */
  status?: CourseStatus
}
/**
 *
 * @export
 * @interface UpdateStudentGrade
 */
export interface UpdateStudentGrade {
  /**
   *
   * @type {string}
   * @memberof UpdateStudentGrade
   */
  student_id?: string
  /**
   *
   * @type {number}
   * @memberof UpdateStudentGrade
   */
  score?: number
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  sex?: UserSexEnum
  /**
   *
   * @type {string}
   * @memberof User
   */
  birth_date?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  address?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  entrance_datetime?: string
  /**
   *
   * @type {EnableStatus}
   * @memberof User
   */
  status?: EnableStatus
}

export const UserSexEnum = {
  M: 'M',
  F: 'F'
} as const

export type UserSexEnum = (typeof UserSexEnum)[keyof typeof UserSexEnum]

/**
 *
 * @export
 * @interface UserAllOf
 */
export interface UserAllOf {
  /**
   *
   * @type {string}
   * @memberof UserAllOf
   */
  sex?: UserAllOfSexEnum
  /**
   *
   * @type {string}
   * @memberof UserAllOf
   */
  birth_date?: string
  /**
   *
   * @type {string}
   * @memberof UserAllOf
   */
  address?: string
  /**
   *
   * @type {string}
   * @memberof UserAllOf
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof UserAllOf
   */
  entrance_datetime?: string
  /**
   *
   * @type {EnableStatus}
   * @memberof UserAllOf
   */
  status?: EnableStatus
}

export const UserAllOfSexEnum = {
  M: 'M',
  F: 'F'
} as const

export type UserAllOfSexEnum = (typeof UserAllOfSexEnum)[keyof typeof UserAllOfSexEnum]

/**
 *
 * @export
 * @interface UserIdentifier
 */
export interface UserIdentifier {
  /**
   *
   * @type {string}
   * @memberof UserIdentifier
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof UserIdentifier
   */
  ref?: string
  /**
   *
   * @type {string}
   * @memberof UserIdentifier
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof UserIdentifier
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof UserIdentifier
   */
  email?: string
}
/**
 *
 * @export
 * @interface Whoami
 */
export interface Whoami {
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  role?: WhoamiRoleEnum
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  bearer?: string
}

export const WhoamiRoleEnum = {
  Student: 'STUDENT',
  Teacher: 'TEACHER',
  Manager: 'MANAGER'
} as const

export type WhoamiRoleEnum = (typeof WhoamiRoleEnum)[keyof typeof WhoamiRoleEnum]

/**
 * PayingApi - axios parameter creator
 * @export
 */
export const PayingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Change current delay penalty configuration
     * @param {CreateDelayPenaltyChange} createDelayPenaltyChange Delay penalties to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDelayPenaltyChange: async (createDelayPenaltyChange: CreateDelayPenaltyChange, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createDelayPenaltyChange' is not null or undefined
      assertParamExists('createDelayPenaltyChange', 'createDelayPenaltyChange', createDelayPenaltyChange)
      const localVarPath = `/delay_penalty_change`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createDelayPenaltyChange, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create student fees
     * @param {string} studentId
     * @param {Array<CreateFee>} createFee Student fees to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStudentFees: async (studentId: string, createFee: Array<CreateFee>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('createStudentFees', 'studentId', studentId)
      // verify required parameter 'createFee' is not null or undefined
      assertParamExists('createStudentFees', 'createFee', createFee)
      const localVarPath = `/students/{student_id}/fees`.replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createFee, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create student payments
     * @param {string} studentId
     * @param {string} feeId
     * @param {Array<CreatePayment>} createPayment Student payments to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStudentPayments: async (
      studentId: string,
      feeId: string,
      createPayment: Array<CreatePayment>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('createStudentPayments', 'studentId', studentId)
      // verify required parameter 'feeId' is not null or undefined
      assertParamExists('createStudentPayments', 'feeId', feeId)
      // verify required parameter 'createPayment' is not null or undefined
      assertParamExists('createStudentPayments', 'createPayment', createPayment)
      const localVarPath = `/students/{student_id}/fees/{fee_id}/payments`
        .replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
        .replace(`{${'fee_id'}}`, encodeURIComponent(String(feeId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createPayment, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get current delay penalty
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDelayPenalty: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/delay_penalty`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all student fees filtered by status
     * @param {'UNPAID' | 'LATE' | 'PAID'} [status] See the PaymentStatus object for its value.
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFees: async (status?: 'UNPAID' | 'LATE' | 'PAID', page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/fees`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get student fee by identifier
     * @param {string} studentId
     * @param {string} feeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentFeeById: async (studentId: string, feeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('getStudentFeeById', 'studentId', studentId)
      // verify required parameter 'feeId' is not null or undefined
      assertParamExists('getStudentFeeById', 'feeId', feeId)
      const localVarPath = `/students/{student_id}/fees/{fee_id}`
        .replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
        .replace(`{${'fee_id'}}`, encodeURIComponent(String(feeId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Fees can be filtered with an optional payment status parameter.
     * @summary Get all student fees ordered by due datetime desc
     * @param {string} studentId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {'UNPAID' | 'PAID' | 'LATE'} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentFees: async (
      studentId: string,
      page?: number,
      pageSize?: number,
      status?: 'UNPAID' | 'PAID' | 'LATE',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('getStudentFees', 'studentId', studentId)
      const localVarPath = `/students/{student_id}/fees`.replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all student payments of a specific fee. Resulting list is ordered by creation datetime desc.
     * @param {string} studentId
     * @param {string} feeId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentPayments: async (studentId: string, feeId: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('getStudentPayments', 'studentId', studentId)
      // verify required parameter 'feeId' is not null or undefined
      assertParamExists('getStudentPayments', 'feeId', feeId)
      const localVarPath = `/students/{student_id}/fees/{fee_id}/payments`
        .replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
        .replace(`{${'fee_id'}}`, encodeURIComponent(String(feeId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * PayingApi - functional programming interface
 * @export
 */
export const PayingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PayingApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Change current delay penalty configuration
     * @param {CreateDelayPenaltyChange} createDelayPenaltyChange Delay penalties to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDelayPenaltyChange(
      createDelayPenaltyChange: CreateDelayPenaltyChange,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelayPenalty>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDelayPenaltyChange(createDelayPenaltyChange, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Create student fees
     * @param {string} studentId
     * @param {Array<CreateFee>} createFee Student fees to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createStudentFees(
      studentId: string,
      createFee: Array<CreateFee>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Fee>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createStudentFees(studentId, createFee, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Create student payments
     * @param {string} studentId
     * @param {string} feeId
     * @param {Array<CreatePayment>} createPayment Student payments to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createStudentPayments(
      studentId: string,
      feeId: string,
      createPayment: Array<CreatePayment>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createStudentPayments(studentId, feeId, createPayment, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get current delay penalty
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDelayPenalty(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelayPenalty>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDelayPenalty(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all student fees filtered by status
     * @param {'UNPAID' | 'LATE' | 'PAID'} [status] See the PaymentStatus object for its value.
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFees(
      status?: 'UNPAID' | 'LATE' | 'PAID',
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Fee>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFees(status, page, pageSize, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get student fee by identifier
     * @param {string} studentId
     * @param {string} feeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentFeeById(
      studentId: string,
      feeId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fee>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentFeeById(studentId, feeId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Fees can be filtered with an optional payment status parameter.
     * @summary Get all student fees ordered by due datetime desc
     * @param {string} studentId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {'UNPAID' | 'PAID' | 'LATE'} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentFees(
      studentId: string,
      page?: number,
      pageSize?: number,
      status?: 'UNPAID' | 'PAID' | 'LATE',
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Fee>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentFees(studentId, page, pageSize, status, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all student payments of a specific fee. Resulting list is ordered by creation datetime desc.
     * @param {string} studentId
     * @param {string} feeId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentPayments(
      studentId: string,
      feeId: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentPayments(studentId, feeId, page, pageSize, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * PayingApi - factory interface
 * @export
 */
export const PayingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PayingApiFp(configuration)
  return {
    /**
     *
     * @summary Change current delay penalty configuration
     * @param {CreateDelayPenaltyChange} createDelayPenaltyChange Delay penalties to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDelayPenaltyChange(createDelayPenaltyChange: CreateDelayPenaltyChange, options?: any): AxiosPromise<DelayPenalty> {
      return localVarFp.createDelayPenaltyChange(createDelayPenaltyChange, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Create student fees
     * @param {string} studentId
     * @param {Array<CreateFee>} createFee Student fees to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStudentFees(studentId: string, createFee: Array<CreateFee>, options?: any): AxiosPromise<Array<Fee>> {
      return localVarFp.createStudentFees(studentId, createFee, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Create student payments
     * @param {string} studentId
     * @param {string} feeId
     * @param {Array<CreatePayment>} createPayment Student payments to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStudentPayments(studentId: string, feeId: string, createPayment: Array<CreatePayment>, options?: any): AxiosPromise<Array<Payment>> {
      return localVarFp.createStudentPayments(studentId, feeId, createPayment, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get current delay penalty
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDelayPenalty(options?: any): AxiosPromise<DelayPenalty> {
      return localVarFp.getDelayPenalty(options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all student fees filtered by status
     * @param {'UNPAID' | 'LATE' | 'PAID'} [status] See the PaymentStatus object for its value.
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFees(status?: 'UNPAID' | 'LATE' | 'PAID', page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Fee>> {
      return localVarFp.getFees(status, page, pageSize, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get student fee by identifier
     * @param {string} studentId
     * @param {string} feeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentFeeById(studentId: string, feeId: string, options?: any): AxiosPromise<Fee> {
      return localVarFp.getStudentFeeById(studentId, feeId, options).then(request => request(axios, basePath))
    },
    /**
     * Fees can be filtered with an optional payment status parameter.
     * @summary Get all student fees ordered by due datetime desc
     * @param {string} studentId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {'UNPAID' | 'PAID' | 'LATE'} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentFees(studentId: string, page?: number, pageSize?: number, status?: 'UNPAID' | 'PAID' | 'LATE', options?: any): AxiosPromise<Array<Fee>> {
      return localVarFp.getStudentFees(studentId, page, pageSize, status, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all student payments of a specific fee. Resulting list is ordered by creation datetime desc.
     * @param {string} studentId
     * @param {string} feeId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentPayments(studentId: string, feeId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Payment>> {
      return localVarFp.getStudentPayments(studentId, feeId, page, pageSize, options).then(request => request(axios, basePath))
    }
  }
}

/**
 * PayingApi - object-oriented interface
 * @export
 * @class PayingApi
 * @extends {BaseAPI}
 */
export class PayingApi extends BaseAPI {
  /**
   *
   * @summary Change current delay penalty configuration
   * @param {CreateDelayPenaltyChange} createDelayPenaltyChange Delay penalties to create
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public createDelayPenaltyChange(createDelayPenaltyChange: CreateDelayPenaltyChange, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .createDelayPenaltyChange(createDelayPenaltyChange, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create student fees
   * @param {string} studentId
   * @param {Array<CreateFee>} createFee Student fees to create
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public createStudentFees(studentId: string, createFee: Array<CreateFee>, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .createStudentFees(studentId, createFee, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create student payments
   * @param {string} studentId
   * @param {string} feeId
   * @param {Array<CreatePayment>} createPayment Student payments to create
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public createStudentPayments(studentId: string, feeId: string, createPayment: Array<CreatePayment>, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .createStudentPayments(studentId, feeId, createPayment, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get current delay penalty
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getDelayPenalty(options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getDelayPenalty(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all student fees filtered by status
   * @param {'UNPAID' | 'LATE' | 'PAID'} [status] See the PaymentStatus object for its value.
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getFees(status?: 'UNPAID' | 'LATE' | 'PAID', page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getFees(status, page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get student fee by identifier
   * @param {string} studentId
   * @param {string} feeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getStudentFeeById(studentId: string, feeId: string, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getStudentFeeById(studentId, feeId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Fees can be filtered with an optional payment status parameter.
   * @summary Get all student fees ordered by due datetime desc
   * @param {string} studentId
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {'UNPAID' | 'PAID' | 'LATE'} [status]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getStudentFees(studentId: string, page?: number, pageSize?: number, status?: 'UNPAID' | 'PAID' | 'LATE', options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getStudentFees(studentId, page, pageSize, status, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all student payments of a specific fee. Resulting list is ordered by creation datetime desc.
   * @param {string} studentId
   * @param {string} feeId
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PayingApi
   */
  public getStudentPayments(studentId: string, feeId: string, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return PayingApiFp(this.configuration)
      .getStudentPayments(studentId, feeId, page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ping`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Who am I? Tells you who you are.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/whoami`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Who am I? Tells you who you are.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async whoami(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SecurityApiFp(configuration)
  return {
    /**
     *
     * @summary pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): AxiosPromise<string> {
      return localVarFp.ping(options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Who am I? Tells you who you are.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami(options?: any): AxiosPromise<Whoami> {
      return localVarFp.whoami(options).then(request => request(axios, basePath))
    }
  }
}

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
  /**
   *
   * @summary pong
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public ping(options?: AxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .ping(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Who am I? Tells you who you are.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public whoami(options?: AxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .whoami(options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * TeachingApi - axios parameter creator
 * @export
 */
export const TeachingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Update groups when `id` are provided, create them otherwise.
     * @summary Create new groups or update existing groups
     * @param {Array<Group>} group Groups to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateGroups: async (group: Array<Group>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'group' is not null or undefined
      assertParamExists('createOrUpdateGroups', 'group', group)
      const localVarPath = `/groups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Update courses when id are provided, create them otherwise.
     * @summary Crupdate courses
     * @param {Array<CrupdateCourse>} crupdateCourse
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateCourses: async (crupdateCourse: Array<CrupdateCourse>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'crupdateCourse' is not null or undefined
      assertParamExists('crupdateCourses', 'crupdateCourse', crupdateCourse)
      const localVarPath = `/courses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(crupdateCourse, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Update exams if ID is provided, otherwise create new exams of the specified course.
     * @param {string} courseId
     * @param {Array<ExamInfo>} examInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateExams: async (courseId: string, examInfo: Array<ExamInfo>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'courseId' is not null or undefined
      assertParamExists('crupdateExams', 'courseId', courseId)
      // verify required parameter 'examInfo' is not null or undefined
      assertParamExists('crupdateExams', 'examInfo', examInfo)
      const localVarPath = `/courses/{course_id}/exams`.replace(`{${'course_id'}}`, encodeURIComponent(String(courseId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(examInfo, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Update students grades
     * @param {string} courseId
     * @param {string} examId
     * @param {Array<UpdateStudentGrade>} updateStudentGrade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateStudentsGrade: async (
      courseId: string,
      examId: string,
      updateStudentGrade: Array<UpdateStudentGrade>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'courseId' is not null or undefined
      assertParamExists('crupdateStudentsGrade', 'courseId', courseId)
      // verify required parameter 'examId' is not null or undefined
      assertParamExists('crupdateStudentsGrade', 'examId', examId)
      // verify required parameter 'updateStudentGrade' is not null or undefined
      assertParamExists('crupdateStudentsGrade', 'updateStudentGrade', updateStudentGrade)
      const localVarPath = `/courses/{course_id}/exams/{exam_id}/grades`
        .replace(`{${'course_id'}}`, encodeURIComponent(String(courseId)))
        .replace(`{${'exam_id'}}`, encodeURIComponent(String(examId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(updateStudentGrade, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get course by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCourseById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCourseById', 'id', id)
      const localVarPath = `/courses/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all courses
     * @param {string} [code] Filter courses by code, case is ignored
     * @param {string} [name] Filter courses by name, case is ignored
     * @param {number} [credits] Filter courses by credits
     * @param {string} [teacherFirstName] Filter courses by teacher firstname, case is ignored
     * @param {string} [teacherLastName] Filter courses by teacher lastname, case is ignored
     * @param {CourseDirection} [creditsOrder]
     * @param {CourseDirection} [codeOrder]
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCourses: async (
      code?: string,
      name?: string,
      credits?: number,
      teacherFirstName?: string,
      teacherLastName?: string,
      creditsOrder?: CourseDirection,
      codeOrder?: CourseDirection,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/courses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (code !== undefined) {
        localVarQueryParameter['code'] = code
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (credits !== undefined) {
        localVarQueryParameter['credits'] = credits
      }

      if (teacherFirstName !== undefined) {
        localVarQueryParameter['teacher_first_name'] = teacherFirstName
      }

      if (teacherLastName !== undefined) {
        localVarQueryParameter['teacher_last_name'] = teacherLastName
      }

      if (creditsOrder !== undefined) {
        localVarQueryParameter['credits_order'] = creditsOrder
      }

      if (codeOrder !== undefined) {
        localVarQueryParameter['code_order'] = codeOrder
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get exam details with the participants and their grades of the specified exam.
     * @param {string} courseId
     * @param {string} examId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExamDetail: async (courseId: string, examId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'courseId' is not null or undefined
      assertParamExists('getExamDetail', 'courseId', courseId)
      // verify required parameter 'examId' is not null or undefined
      assertParamExists('getExamDetail', 'examId', examId)
      const localVarPath = `/courses/{course_id}/exams/{exam_id}/details`
        .replace(`{${'course_id'}}`, encodeURIComponent(String(courseId)))
        .replace(`{${'exam_id'}}`, encodeURIComponent(String(examId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all exam infos of a specified course
     * @param {string} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExamsByCourseId: async (courseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'courseId' is not null or undefined
      assertParamExists('getExamsByCourseId', 'courseId', courseId)
      const localVarPath = `/courses/{course_id}/exams`.replace(`{${'course_id'}}`, encodeURIComponent(String(courseId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get group by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getGroupById', 'id', id)
      const localVarPath = `/groups/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/groups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Return a participant with his grade for the specified exam
     * @param {string} courseId
     * @param {string} examId
     * @param {string} participantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParticipantById: async (courseId: string, examId: string, participantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'courseId' is not null or undefined
      assertParamExists('getParticipantById', 'courseId', courseId)
      // verify required parameter 'examId' is not null or undefined
      assertParamExists('getParticipantById', 'examId', examId)
      // verify required parameter 'participantId' is not null or undefined
      assertParamExists('getParticipantById', 'participantId', participantId)
      const localVarPath = `/courses/{course_id}/exams/{exam_id}/participants/{participant_id}`
        .replace(`{${'course_id'}}`, encodeURIComponent(String(courseId)))
        .replace(`{${'exam_id'}}`, encodeURIComponent(String(examId)))
        .replace(`{${'participant_id'}}`, encodeURIComponent(String(participantId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all grades of a student in every course that had an exam.
     * @param {string} studentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentGrades: async (studentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('getStudentGrades', 'studentId', studentId)
      const localVarPath = `/students/{student_id}/grades`.replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * TeachingApi - functional programming interface
 * @export
 */
export const TeachingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TeachingApiAxiosParamCreator(configuration)
  return {
    /**
     * Update groups when `id` are provided, create them otherwise.
     * @summary Create new groups or update existing groups
     * @param {Array<Group>} group Groups to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrUpdateGroups(
      group: Array<Group>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateGroups(group, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update courses when id are provided, create them otherwise.
     * @summary Crupdate courses
     * @param {Array<CrupdateCourse>} crupdateCourse
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateCourses(
      crupdateCourse: Array<CrupdateCourse>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateCourses(crupdateCourse, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Update exams if ID is provided, otherwise create new exams of the specified course.
     * @param {string} courseId
     * @param {Array<ExamInfo>} examInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateExams(
      courseId: string,
      examInfo: Array<ExamInfo>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExamInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateExams(courseId, examInfo, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Update students grades
     * @param {string} courseId
     * @param {string} examId
     * @param {Array<UpdateStudentGrade>} updateStudentGrade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateStudentsGrade(
      courseId: string,
      examId: string,
      updateStudentGrade: Array<UpdateStudentGrade>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateStudentsGrade(courseId, examId, updateStudentGrade, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get course by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCourseById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseById(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all courses
     * @param {string} [code] Filter courses by code, case is ignored
     * @param {string} [name] Filter courses by name, case is ignored
     * @param {number} [credits] Filter courses by credits
     * @param {string} [teacherFirstName] Filter courses by teacher firstname, case is ignored
     * @param {string} [teacherLastName] Filter courses by teacher lastname, case is ignored
     * @param {CourseDirection} [creditsOrder]
     * @param {CourseDirection} [codeOrder]
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCourses(
      code?: string,
      name?: string,
      credits?: number,
      teacherFirstName?: string,
      teacherLastName?: string,
      creditsOrder?: CourseDirection,
      codeOrder?: CourseDirection,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(
        code,
        name,
        credits,
        teacherFirstName,
        teacherLastName,
        creditsOrder,
        codeOrder,
        page,
        pageSize,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get exam details with the participants and their grades of the specified exam.
     * @param {string} courseId
     * @param {string} examId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExamDetail(
      courseId: string,
      examId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getExamDetail(courseId, examId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all exam infos of a specified course
     * @param {string} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExamsByCourseId(
      courseId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExamInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getExamsByCourseId(courseId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get group by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGroupById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupById(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGroups(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Return a participant with his grade for the specified exam
     * @param {string} courseId
     * @param {string} examId
     * @param {string} participantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getParticipantById(
      courseId: string,
      examId: string,
      participantId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGrade>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getParticipantById(courseId, examId, participantId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all grades of a student in every course that had an exam.
     * @param {string} studentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentGrades(
      studentId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudentCourseExam>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentGrades(studentId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * TeachingApi - factory interface
 * @export
 */
export const TeachingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TeachingApiFp(configuration)
  return {
    /**
     * Update groups when `id` are provided, create them otherwise.
     * @summary Create new groups or update existing groups
     * @param {Array<Group>} group Groups to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateGroups(group: Array<Group>, options?: any): AxiosPromise<Array<Group>> {
      return localVarFp.createOrUpdateGroups(group, options).then(request => request(axios, basePath))
    },
    /**
     * Update courses when id are provided, create them otherwise.
     * @summary Crupdate courses
     * @param {Array<CrupdateCourse>} crupdateCourse
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateCourses(crupdateCourse: Array<CrupdateCourse>, options?: any): AxiosPromise<Array<Course>> {
      return localVarFp.crupdateCourses(crupdateCourse, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Update exams if ID is provided, otherwise create new exams of the specified course.
     * @param {string} courseId
     * @param {Array<ExamInfo>} examInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateExams(courseId: string, examInfo: Array<ExamInfo>, options?: any): AxiosPromise<Array<ExamInfo>> {
      return localVarFp.crupdateExams(courseId, examInfo, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Update students grades
     * @param {string} courseId
     * @param {string} examId
     * @param {Array<UpdateStudentGrade>} updateStudentGrade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateStudentsGrade(courseId: string, examId: string, updateStudentGrade: Array<UpdateStudentGrade>, options?: any): AxiosPromise<ExamDetail> {
      return localVarFp.crupdateStudentsGrade(courseId, examId, updateStudentGrade, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get course by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCourseById(id: string, options?: any): AxiosPromise<Course> {
      return localVarFp.getCourseById(id, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all courses
     * @param {string} [code] Filter courses by code, case is ignored
     * @param {string} [name] Filter courses by name, case is ignored
     * @param {number} [credits] Filter courses by credits
     * @param {string} [teacherFirstName] Filter courses by teacher firstname, case is ignored
     * @param {string} [teacherLastName] Filter courses by teacher lastname, case is ignored
     * @param {CourseDirection} [creditsOrder]
     * @param {CourseDirection} [codeOrder]
     * @param {number} [page] Set value to 1 by default if null is provided
     * @param {number} [pageSize] Set value to 15 by default if null is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCourses(
      code?: string,
      name?: string,
      credits?: number,
      teacherFirstName?: string,
      teacherLastName?: string,
      creditsOrder?: CourseDirection,
      codeOrder?: CourseDirection,
      page?: number,
      pageSize?: number,
      options?: any
    ): AxiosPromise<Array<Course>> {
      return localVarFp
        .getCourses(code, name, credits, teacherFirstName, teacherLastName, creditsOrder, codeOrder, page, pageSize, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get exam details with the participants and their grades of the specified exam.
     * @param {string} courseId
     * @param {string} examId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExamDetail(courseId: string, examId: string, options?: any): AxiosPromise<ExamDetail> {
      return localVarFp.getExamDetail(courseId, examId, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all exam infos of a specified course
     * @param {string} courseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExamsByCourseId(courseId: string, options?: any): AxiosPromise<Array<ExamInfo>> {
      return localVarFp.getExamsByCourseId(courseId, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get group by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupById(id: string, options?: any): AxiosPromise<Group> {
      return localVarFp.getGroupById(id, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroups(options?: any): AxiosPromise<Array<Group>> {
      return localVarFp.getGroups(options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Return a participant with his grade for the specified exam
     * @param {string} courseId
     * @param {string} examId
     * @param {string} participantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParticipantById(courseId: string, examId: string, participantId: string, options?: any): AxiosPromise<StudentGrade> {
      return localVarFp.getParticipantById(courseId, examId, participantId, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all grades of a student in every course that had an exam.
     * @param {string} studentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentGrades(studentId: string, options?: any): AxiosPromise<Array<StudentCourseExam>> {
      return localVarFp.getStudentGrades(studentId, options).then(request => request(axios, basePath))
    }
  }
}

/**
 * TeachingApi - object-oriented interface
 * @export
 * @class TeachingApi
 * @extends {BaseAPI}
 */
export class TeachingApi extends BaseAPI {
  /**
   * Update groups when `id` are provided, create them otherwise.
   * @summary Create new groups or update existing groups
   * @param {Array<Group>} group Groups to update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public createOrUpdateGroups(group: Array<Group>, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .createOrUpdateGroups(group, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Update courses when id are provided, create them otherwise.
   * @summary Crupdate courses
   * @param {Array<CrupdateCourse>} crupdateCourse
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public crupdateCourses(crupdateCourse: Array<CrupdateCourse>, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .crupdateCourses(crupdateCourse, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update exams if ID is provided, otherwise create new exams of the specified course.
   * @param {string} courseId
   * @param {Array<ExamInfo>} examInfo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public crupdateExams(courseId: string, examInfo: Array<ExamInfo>, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .crupdateExams(courseId, examInfo, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update students grades
   * @param {string} courseId
   * @param {string} examId
   * @param {Array<UpdateStudentGrade>} updateStudentGrade
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public crupdateStudentsGrade(courseId: string, examId: string, updateStudentGrade: Array<UpdateStudentGrade>, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .crupdateStudentsGrade(courseId, examId, updateStudentGrade, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get course by identifier
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getCourseById(id: string, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getCourseById(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all courses
   * @param {string} [code] Filter courses by code, case is ignored
   * @param {string} [name] Filter courses by name, case is ignored
   * @param {number} [credits] Filter courses by credits
   * @param {string} [teacherFirstName] Filter courses by teacher firstname, case is ignored
   * @param {string} [teacherLastName] Filter courses by teacher lastname, case is ignored
   * @param {CourseDirection} [creditsOrder]
   * @param {CourseDirection} [codeOrder]
   * @param {number} [page] Set value to 1 by default if null is provided
   * @param {number} [pageSize] Set value to 15 by default if null is provided
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getCourses(
    code?: string,
    name?: string,
    credits?: number,
    teacherFirstName?: string,
    teacherLastName?: string,
    creditsOrder?: CourseDirection,
    codeOrder?: CourseDirection,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig
  ) {
    return TeachingApiFp(this.configuration)
      .getCourses(code, name, credits, teacherFirstName, teacherLastName, creditsOrder, codeOrder, page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get exam details with the participants and their grades of the specified exam.
   * @param {string} courseId
   * @param {string} examId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getExamDetail(courseId: string, examId: string, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getExamDetail(courseId, examId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all exam infos of a specified course
   * @param {string} courseId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getExamsByCourseId(courseId: string, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getExamsByCourseId(courseId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get group by identifier
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getGroupById(id: string, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getGroupById(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all groups
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getGroups(options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getGroups(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Return a participant with his grade for the specified exam
   * @param {string} courseId
   * @param {string} examId
   * @param {string} participantId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getParticipantById(courseId: string, examId: string, participantId: string, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getParticipantById(courseId, examId, participantId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all grades of a student in every course that had an exam.
   * @param {string} studentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getStudentGrades(studentId: string, options?: AxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getStudentGrades(studentId, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Update students when `id` are provided, create them otherwise.
     * @summary Create new students or update existing students
     * @param {Array<Student>} student
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateStudents: async (student: Array<Student>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'student' is not null or undefined
      assertParamExists('createOrUpdateStudents', 'student', student)
      const localVarPath = `/students`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(student, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Update teachers when `id` are provided, create them otherwise.
     * @summary Create new teachers or update existing teachers
     * @param {Array<Teacher>} teacher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateTeachers: async (teacher: Array<Teacher>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'teacher' is not null or undefined
      assertParamExists('createOrUpdateTeachers', 'teacher', teacher)
      const localVarPath = `/teachers`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(teacher, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get manager by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagerById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getManagerById', 'id', id)
      const localVarPath = `/managers/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all managers
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagers: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/managers`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get student by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getStudentById', 'id', id)
      const localVarPath = `/students/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get a specific student courses
     * @param {string} studentId
     * @param {CourseStatus} [status] By default, LINKED courses are provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentCoursesById: async (studentId: string, status?: CourseStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('getStudentCoursesById', 'studentId', studentId)
      const localVarPath = `/students/{student_id}/courses`.replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all students
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [ref] Filter students by ref, case is ignored
     * @param {string} [firstName] Filter students by first name, case is ignored
     * @param {string} [lastName] Filter students by last name, case is ignored
     * @param {string} [courseId] Filter students by course they are linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudents: async (
      page?: number,
      pageSize?: number,
      ref?: string,
      firstName?: string,
      lastName?: string,
      courseId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/students`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      if (ref !== undefined) {
        localVarQueryParameter['ref'] = ref
      }

      if (firstName !== undefined) {
        localVarQueryParameter['first_name'] = firstName
      }

      if (lastName !== undefined) {
        localVarQueryParameter['last_name'] = lastName
      }

      if (courseId !== undefined) {
        localVarQueryParameter['course_id'] = courseId
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get teacher by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeacherById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getTeacherById', 'id', id)
      const localVarPath = `/teachers/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all teachers
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [ref] Filter teachers by ref, case is ignored
     * @param {string} [firstName] Filter teachers by first name, case is ignored
     * @param {string} [lastName] Filter teachers by last name, case is ignored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeachers: async (
      page?: number,
      pageSize?: number,
      ref?: string,
      firstName?: string,
      lastName?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/teachers`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize
      }

      if (ref !== undefined) {
        localVarQueryParameter['ref'] = ref
      }

      if (firstName !== undefined) {
        localVarQueryParameter['first_name'] = firstName
      }

      if (lastName !== undefined) {
        localVarQueryParameter['last_name'] = lastName
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Link or unlink courses to a specific student
     * @param {string} studentId
     * @param {Array<UpdateStudentCourse>} updateStudentCourse
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStudentCourses: async (
      studentId: string,
      updateStudentCourse: Array<UpdateStudentCourse>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('updateStudentCourses', 'studentId', studentId)
      // verify required parameter 'updateStudentCourse' is not null or undefined
      assertParamExists('updateStudentCourses', 'updateStudentCourse', updateStudentCourse)
      const localVarPath = `/students/{student_id}/courses`.replace(`{${'student_id'}}`, encodeURIComponent(String(studentId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(updateStudentCourse, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
  return {
    /**
     * Update students when `id` are provided, create them otherwise.
     * @summary Create new students or update existing students
     * @param {Array<Student>} student
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrUpdateStudents(
      student: Array<Student>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateOrUpdateStudents200ResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateStudents(student, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update teachers when `id` are provided, create them otherwise.
     * @summary Create new teachers or update existing teachers
     * @param {Array<Teacher>} teacher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrUpdateTeachers(
      teacher: Array<Teacher>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Teacher>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateTeachers(teacher, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get manager by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getManagerById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manager>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getManagerById(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all managers
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getManagers(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Manager>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getManagers(page, pageSize, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get student by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Student>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentById(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get a specific student courses
     * @param {string} studentId
     * @param {CourseStatus} [status] By default, LINKED courses are provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentCoursesById(
      studentId: string,
      status?: CourseStatus,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudentCoursesById(studentId, status, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all students
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [ref] Filter students by ref, case is ignored
     * @param {string} [firstName] Filter students by first name, case is ignored
     * @param {string} [lastName] Filter students by last name, case is ignored
     * @param {string} [courseId] Filter students by course they are linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudents(
      page?: number,
      pageSize?: number,
      ref?: string,
      firstName?: string,
      lastName?: string,
      courseId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Student>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStudents(page, pageSize, ref, firstName, lastName, courseId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get teacher by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTeacherById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTeacherById(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all teachers
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [ref] Filter teachers by ref, case is ignored
     * @param {string} [firstName] Filter teachers by first name, case is ignored
     * @param {string} [lastName] Filter teachers by last name, case is ignored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTeachers(
      page?: number,
      pageSize?: number,
      ref?: string,
      firstName?: string,
      lastName?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Teacher>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTeachers(page, pageSize, ref, firstName, lastName, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Link or unlink courses to a specific student
     * @param {string} studentId
     * @param {Array<UpdateStudentCourse>} updateStudentCourse
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateStudentCourses(
      studentId: string,
      updateStudentCourse: Array<UpdateStudentCourse>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateStudentCourses(studentId, updateStudentCourse, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    }
  }
}

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UsersApiFp(configuration)
  return {
    /**
     * Update students when `id` are provided, create them otherwise.
     * @summary Create new students or update existing students
     * @param {Array<Student>} student
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateStudents(student: Array<Student>, options?: any): AxiosPromise<Array<CreateOrUpdateStudents200ResponseInner>> {
      return localVarFp.createOrUpdateStudents(student, options).then(request => request(axios, basePath))
    },
    /**
     * Update teachers when `id` are provided, create them otherwise.
     * @summary Create new teachers or update existing teachers
     * @param {Array<Teacher>} teacher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrUpdateTeachers(teacher: Array<Teacher>, options?: any): AxiosPromise<Array<Teacher>> {
      return localVarFp.createOrUpdateTeachers(teacher, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get manager by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagerById(id: string, options?: any): AxiosPromise<Manager> {
      return localVarFp.getManagerById(id, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all managers
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagers(page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Manager>> {
      return localVarFp.getManagers(page, pageSize, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get student by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentById(id: string, options?: any): AxiosPromise<Student> {
      return localVarFp.getStudentById(id, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get a specific student courses
     * @param {string} studentId
     * @param {CourseStatus} [status] By default, LINKED courses are provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentCoursesById(studentId: string, status?: CourseStatus, options?: any): AxiosPromise<Array<Course>> {
      return localVarFp.getStudentCoursesById(studentId, status, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all students
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [ref] Filter students by ref, case is ignored
     * @param {string} [firstName] Filter students by first name, case is ignored
     * @param {string} [lastName] Filter students by last name, case is ignored
     * @param {string} [courseId] Filter students by course they are linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudents(
      page?: number,
      pageSize?: number,
      ref?: string,
      firstName?: string,
      lastName?: string,
      courseId?: string,
      options?: any
    ): AxiosPromise<Array<Student>> {
      return localVarFp.getStudents(page, pageSize, ref, firstName, lastName, courseId, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get teacher by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeacherById(id: string, options?: any): AxiosPromise<Teacher> {
      return localVarFp.getTeacherById(id, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get all teachers
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [ref] Filter teachers by ref, case is ignored
     * @param {string} [firstName] Filter teachers by first name, case is ignored
     * @param {string} [lastName] Filter teachers by last name, case is ignored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeachers(page?: number, pageSize?: number, ref?: string, firstName?: string, lastName?: string, options?: any): AxiosPromise<Array<Teacher>> {
      return localVarFp.getTeachers(page, pageSize, ref, firstName, lastName, options).then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Link or unlink courses to a specific student
     * @param {string} studentId
     * @param {Array<UpdateStudentCourse>} updateStudentCourse
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStudentCourses(studentId: string, updateStudentCourse: Array<UpdateStudentCourse>, options?: any): AxiosPromise<Array<Course>> {
      return localVarFp.updateStudentCourses(studentId, updateStudentCourse, options).then(request => request(axios, basePath))
    }
  }
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * Update students when `id` are provided, create them otherwise.
   * @summary Create new students or update existing students
   * @param {Array<Student>} student
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createOrUpdateStudents(student: Array<Student>, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .createOrUpdateStudents(student, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Update teachers when `id` are provided, create them otherwise.
   * @summary Create new teachers or update existing teachers
   * @param {Array<Teacher>} teacher
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createOrUpdateTeachers(teacher: Array<Teacher>, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .createOrUpdateTeachers(teacher, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get manager by identifier
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getManagerById(id: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getManagerById(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all managers
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getManagers(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getManagers(page, pageSize, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get student by identifier
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getStudentById(id: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getStudentById(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get a specific student courses
   * @param {string} studentId
   * @param {CourseStatus} [status] By default, LINKED courses are provided.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getStudentCoursesById(studentId: string, status?: CourseStatus, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getStudentCoursesById(studentId, status, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all students
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {string} [ref] Filter students by ref, case is ignored
   * @param {string} [firstName] Filter students by first name, case is ignored
   * @param {string} [lastName] Filter students by last name, case is ignored
   * @param {string} [courseId] Filter students by course they are linked to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getStudents(page?: number, pageSize?: number, ref?: string, firstName?: string, lastName?: string, courseId?: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getStudents(page, pageSize, ref, firstName, lastName, courseId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get teacher by identifier
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getTeacherById(id: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getTeacherById(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all teachers
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {string} [ref] Filter teachers by ref, case is ignored
   * @param {string} [firstName] Filter teachers by first name, case is ignored
   * @param {string} [lastName] Filter teachers by last name, case is ignored
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getTeachers(page?: number, pageSize?: number, ref?: string, firstName?: string, lastName?: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getTeachers(page, pageSize, ref, firstName, lastName, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Link or unlink courses to a specific student
   * @param {string} studentId
   * @param {Array<UpdateStudentCourse>} updateStudentCourse
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateStudentCourses(studentId: string, updateStudentCourse: Array<UpdateStudentCourse>, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .updateStudentCourses(studentId, updateStudentCourse, options)
      .then(request => request(this.axios, this.basePath))
  }
}
